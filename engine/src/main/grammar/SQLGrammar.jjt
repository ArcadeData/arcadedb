/*
 * Copyright Â© 2021-present Arcade Data Ltd (info@arcadedata.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: 2021-present Arcade Data Ltd (info@arcadedata.com)
 * SPDX-License-Identifier: Apache-2.0
 */

options {
  TRACK_TOKENS = true;
    JDK_VERSION = "21";
    MULTI=true;
    VISITOR=false;
    STATIC=false;
    USER_CHAR_STREAM = true ;
    JAVA_UNICODE_ESCAPE=true;
    NODE_PREFIX="";
}

PARSER_BEGIN(SqlParser)

package com.arcadedb.query.sql.parser;

import java.io.*;
import java.util.*;
import javax.annotation.processing.Generated;
import com.arcadedb.database.Database;
import com.arcadedb.exception.CommandParsingException;
import com.arcadedb.index.lsm.LSMTreeIndexAbstract;

/** Database Sql grammar. */
@Generated("JavaCC") // EXCLUDE INSPECTION FROM JACOCO
public class SqlParser {

  private int inputParamCount = 0;
  private Database database;
  private String command;

  public SqlParser(final Database database, final String command) {
    this(database, new ByteArrayInputStream(command.getBytes()));
    this.command = command;
  }

  public SqlParser(final Database database, final InputStream stream) {
    this(new JavaCharStream(stream));
    this.database = database;
  }

  public SqlParser(final Database database, InputStream stream, String charset) throws java.io.UnsupportedEncodingException {
    this(new JavaCharStream(stream, charset));
    this.database = database;
  }

  public Database getDatabase(){
    return database;
  }
}

PARSER_END(SqlParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */
MORE :
{
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
  |
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  <~[] >
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "-- "(~["\n"])* ("\n")? > : DEFAULT
}

/* reserved words - Phase A: Most keywords converted to IGNORE_CASE */
TOKEN [IGNORE_CASE]:
{
  <ALIASES: "aliases">
  | <ALIGN: "align">
  | <BATCH: "batch">
  | <SELECT: "select">
  | <TRAVERSE: "traverse">
  | <MATCH: "match">
  | <INSERT: "insert">
  | <CREATE: "create">
  | <CUSTOM: "custom">
  | <DELETE: "delete">
  | <DOCUMENT: "document">
  | <VERTEX: "vertex">
  | <EDGE: "edge">
  | <UPDATE: "update">
  | <UPSERT: "upsert">
  | <FROM: "from">
  | <TO: "to">
  | <WHERE: "where">
  | <WHILE: "while">
  | <INTO: "into">
  | <VALUE: "value">
  | <VALUES: "values">
  | <SET: "set">
  | <ADD: "add">
  | <PUT: "put">
  | <MERGE: "merge">
  | <CONTENT: "content">
  | <REMOVE: "remove">
  | <INCREMENT: "increment">
  | <AND: "and">
  | <OR: "or">
  | <NULL: "null">
  | <DEFINE: "define">
  | <DEFINED: "defined">
  | <ORDER_BY: "order" ([" "])+ "by">
  | <GROUP_BY: "group" ([" "])+ "by">
  | <BY: "by">
  | <BREAK: "break">
  | <LIMIT: "limit">
  | <SKIP2: "skip">
  | <ERROR2: "error">
  | <OF: "of">
  | <OFFSET: "offset">
  | <TIMEOUT: "timeout">
  | <ASC: "asc">
  | <AS: "as">
  | <DESC: "desc">
  | <RETURN: "return">
  | <BEFORE: "before">
  | <AFTER: "after">
  | <RECORD: "record">
  | <WAIT: "wait">
  | <RETRY: "retry">
  | <LET: "let">
  | <LOCK: "lock">
  | <CHECK: "check">
  | <UNSAFE: "unsafe">
  | <STRATEGY: "strategy">
  | <DEPTH_FIRST: "depth_first">
  | <BREADTH_FIRST: "breadth_first">
  | <NEAR: "near">
  | <WITH: "with">
  | <WITHIN: "within">
  | <UNWIND: "unwind">
  | <MAXDEPTH: "maxdepth">
  | <MINDEPTH: "mindepth">
  | <TYPE: "type">
  | <SUPERTYPE: "supertype">
  | <TYPES: "types">
  | <EXCEPTION: "exception">
  | <PROFILE: "profile">
  | <ON: "on">
  | <OFF: "off">
  | <COMPRESS: "compress">
  | <TRUNCATE: "truncate">
  | <POLYMORPHIC: "polymorphic">
  | <FIND: "find">
  | <EXTENDS: "extends">
  | <BACKUP: "backup">
  | <BUCKETS: "buckets">
  | <BUCKETSELECTIONSTRATEGY: "bucketselectionstrategy">
  | <ALTER: "alter">
  | <NAME: "name">
  | <ADDBUCKET: "addbucket">
  | <REMOVEBUCKET: "removebucket">
  | <DROP: "drop">
  | <PROPERTY: "property">
  | <HIDDEN: "hidden">
  | <FORCE: "force">
  | <SCHEMA: "schema">
  | <NULL_STRATEGY: "null_strategy">
  | <ENGINE: "engine">
  | <METADATA: "metadata">
  | <REBUILD: "rebuild">
  | <FORMAT: "format">
  | <OVERWRITE: "overwrite">
  | <EXPORT: "export">
  | <IMPORT: "import">
  | <DATABASE: "database">
  | <OPTIMIZE: "optimize">
  | <LINK: "link">
  | <INVERSE: "inverse">
  | <EXPLAIN: "explain">
  | <GRANT: "grant">
  | <REVOKE: "revoke">
  | <READ: "read">
  | <EXECUTE: "execute">
  | <ALL: "all">
  | <NONE: "none">
  | <FUNCTION: "function">
  | <PARAMETERS: "parameters">
  | <LANGUAGE: "language">
  | <BEGIN: "begin">
  | <COMMIT: "commit">
  | <ROLLBACK: "rollback">
  | <IF: "if">
  | <ELSE: "else">
  | <CONTINUE: "continue">
  | <FAIL: "fail">
  | <FIX: "fix">
  | <ISOLATION: "isolation">
  | <SLEEP: "sleep">
  | <CONSOLE: "console">
  | <START: "start">
  | <OPTIONAL: "optional">
  | <COUNT: "count">
  | <DISTINCT: "distinct">
  | <EXISTS: "exists">
  | <FOREACH: "foreach">
  | <MOVE: "move">
  | <DEPTH_ALIAS: "depthalias">
  | <PATH_ALIAS: "pathalias">
  | <IDENTIFIED: "identified">
  | <RID: "rid">
  | <SYSTEM: "system">
  | <UNIDIRECTIONAL: "unidirectional">
  | <BUCKET: "bucket">
  | <INDEX: "index">
}

/* Tokens still using verbose pattern (attribute tokens and compound definitions) */
TOKEN:
{
  <THIS: "@" ( ("t"|"T")("h"|"H")("i"|"I")("s"|"S") )>
  | <RECORD_ATTRIBUTE: <RID_ATTR> | <TYPE_ATTR> | <RID_ID_ATTR> | <RID_POS_ATTR> | <PROPS_ATTR> | <OUT_ATTR> | <IN_ATTR> >
  | <RID_ATTR: "@" ( ("r"|"R")("i"|"I")("d"|"D") )>
  | <RID_STRING: "\"@" ( ("r"|"R")("i"|"I")("d"|"D") ) "\"" >
  | <OUT_ATTR: "@" ( ("o"|"O")("u"|"U")("t"|"T") )>
  | <IN_ATTR: "@" ( ("i"|"I")("n"|"N") )>
  | <#TYPE_ATTR: "@" ( ("t"|"T")("y"|"Y")("p"|"P")("e"|"E") )>
  | <#RID_ID_ATTR: "@" ( ("r"|"R")("i"|"I")("d"|"D") "_" ("i"|"I")("d"|"D") )>
  | <#RID_POS_ATTR: "@" ( ("r"|"R")("i"|"I")("d"|"D") "_" ("p"|"P")("o"|"O")("s"|"S") )>
  | <#PROPS_ATTR: "@" ( ("p"|"P")("r"|"R")("o"|"O")("p"|"P")("s"|"S") )>
}

/* LITERALS */

TOKEN :
{
  <INTEGER_LITERAL:
    <DECIMAL_LITERAL> (["l","L"])?
    | <HEX_LITERAL> (["l","L"])?
    | <OCTAL_LITERAL> (["l","L"])?
  >
  | <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
  | <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
  | <#OCTAL_LITERAL: "0" (["0"-"7"])* >
  | <FLOATING_POINT_LITERAL:
      <DECIMAL_FLOATING_POINT_LITERAL>
      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
    >
  | <#DECIMAL_FLOATING_POINT_LITERAL:
      (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
    >
  | <#DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
  | <#HEXADECIMAL_FLOATING_POINT_LITERAL:
      "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
    >
  | <#HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >
  | <CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
      | ("\\"
        ( ["n","t","b","r","f","\\","'","\"","/"]
        | ["0"-"7"] ( ["0"-"7"] )?
        | ["0"-"3"] ["0"-"7"] ["0"-"7"]
        )
        )
      )
      "'"
    >
  | <STRING_LITERAL:
    (
      "\""
      ( (~["\n","\r","\"","\\"])
      | ("\\"
          ( ["n","t","b","r","f","\\","\"","/","%","?"])
        )
      )*
      "\""
    )
    |
    (
      "'"
      ( (~["\n","\r","'","\\"])
      | ("\\"
          ( ["n","t","b","r","f","\\","'","/","%","?"])
        )
      )*
      "'"
    )
  >
  | <INTEGER_RANGE:
  (<MINUS>)? <INTEGER_LITERAL> <RANGE> (<MINUS>)?<INTEGER_LITERAL>
  >
  | <ELLIPSIS_INTEGER_RANGE:
  (<MINUS>)? <INTEGER_LITERAL> <ELLIPSIS> (<MINUS>)?<INTEGER_LITERAL>
  >
  | <TRUE: ("T"|"t")("R"|"r")("U"|"u")("E"|"e") >
  | <FALSE: ("F"|"f")("A"|"a")("L"|"l")("S"|"s")("E"|"e") >
}

/* SEPARATORS */
TOKEN :
{
  <LPAREN: "(" >
  | <RPAREN: ")" >
  | <LBRACE: "{" >
  | <RBRACE: "}" >
  | <LBRACKET: "[" >
  | <RBRACKET: "]" >
  | <SEMICOLON: ";" >
  | <COMMA: "," >
  | <DOT: "." >
  | <AT: "@" >
  | <DOLLAR: "$" >
  | <BACKTICK: "`" >
}

/* OPERATORS */
TOKEN :
{
  <EQ: "=" >
  | <EQEQ: "==" >
  | <NSEQ: "<=>" >
  | <LT: "<" >
  | <GT: ">" >
  | <BANG: "!" >
  | <TILDE: "~" >
  | <HOOK: "?" >
  | <COLON: ":" >
  | <LE: "<=" >
  | <GE: ">=" >
  | <NE: "!=" >
  | <NEQ: "<>" >
  | <SC_OR: "||" >
  | <SC_AND: "&&" >
  | <INCR: "++" >
  | <DECR: "--" >
  | <PLUS: "+" >
  | <MINUS: "-" >
  | <STAR: "*" >
  | <SLASH: "/" >
  | <BIT_AND: "&" >
  | <NULL_COALESCING: "??" >
  | <BIT_OR: "|" >
  | <XOR: "^" >
  | <REM: "%" >
  | <LSHIFT: "<<" >
  | <PLUSASSIGN: "+=" >
  | <MINUSASSIGN: "-=" >
  | <STARASSIGN: "*=" >
  | <SLASHASSIGN: "/=" >
  | <ANDASSIGN: "&=" >
  | <ORASSIGN: "|=" >
  | <XORASSIGN: "^=" >
  | <REMASSIGN: "%=" >
  | <LSHIFTASSIGN: "<<=" >
  | <RSIGNEDSHIFTASSIGN: ">>=" >
  | <RUNSIGNEDSHIFTASSIGN: ">>>=" >
  | <RSHIFT: ">>" >
  | <RUNSIGNEDSHIFT: ">>>" >
  | <ELLIPSIS: "..." >
  | <RANGE: ".." >
  | <NOT: ("N"|"n")("O"|"o")("T"|"t")  >
  | <IN: ("I"|"i")("N"|"n") >
  | <LIKE: ("L"|"l")("I"|"i")("K"|"k")("E"|"e") >
  | <ILIKE: ("I"|"i")("L"|"l")("I"|"i")("K"|"k")("E"|"e") >
  | <IS: "is"|"IS"|"Is"|"iS" >
  | <BETWEEN: ("B"|"b")("E"|"e")("T"|"t")("W"|"w")("E"|"e")("E"|"e")("N"|"n")>
  | <CONTAINS: ("C"|"c")("O"|"o")("N"|"n")("T"|"t")("A"|"a")("I"|"i")("N"|"n")("S"|"s") >
  | <CONTAINSALL: ("C"|"c")("O"|"o")("N"|"n")("T"|"t")("A"|"a")("I"|"i")("N"|"n")("S"|"s")("A"|"a")("L"|"l")("L"|"l") >
  | <CONTAINSANY: ("C"|"c")("O"|"o")("N"|"n")("T"|"t")("A"|"a")("I"|"i")("N"|"n")("S"|"s")("A"|"a")("N"|"n")("Y"|"y") >
  | <CONTAINSKEY: ("C"|"c")("O"|"o")("N"|"n")("T"|"t")("A"|"a")("I"|"i")("N"|"n")("S"|"s")("K"|"k")("E"|"e")("Y"|"y") >
  | <CONTAINSVALUE: ("C"|"c")("O"|"o")("N"|"n")("T"|"t")("A"|"a")("I"|"i")("N"|"n")("S"|"s")("V"|"v")("A"|"a")("L"|"l")("U"|"u")("E"|"e") >
  | <CONTAINSTEXT: ("C"|"c")("O"|"o")("N"|"n")("T"|"t")("A"|"a")("I"|"i")("N"|"n")("S"|"s")("T"|"t")("E"|"e")("X"|"x")("T"|"t") >
  | <MATCHES: ("M"|"m")("A"|"a")("T"|"t")("C"|"c")("H"|"h")("E"|"e")("S"|"s") >
  | <KEY: ("K"|"k")("E"|"e")("Y"|"y") >
  | <ITEM: ("I"|"i")("T"|"t")("E"|"e")("M"|"m") >
  | <INSTANCEOF: ("I"|"i")("N"|"n")("S"|"s")("T"|"t")("A"|"a")("N"|"n")("C"|"c")("E"|"e")("O"|"o")("F"|"f") >
}

TOKEN :
{
  <IDENTIFIER: ( ((<DOLLAR>) | <LETTER>) (<PART_LETTER>)* ) >
  | <QUOTED_IDENTIFIER: ("`" (~["`"] | "\\`") (~["`"] | "\\`")*  "`") >
  | <INDEX_COLON: ("I"|"i")("N"|"n")("D"|"d")("E"|"e")("X"|"x") ":" >
  | <INDEXVALUES_IDENTIFIER: ("I"|"i")("N"|"n")("D"|"d")("E"|"e")("X"|"x")("V"|"v")("A"|"a")("L"|"l")("U"|"u")("E"|"e")("S"|"s") ":" ("__@recordmap@___")? <IDENTIFIER> ( ( <DOT> | <MINUS> ) <IDENTIFIER> )* >
  | <INDEXVALUESASC_IDENTIFIER:("I"|"i")("N"|"n")("D"|"d")("E"|"e")("X"|"x")("V"|"v")("A"|"a")("L"|"l")("U"|"u")("E"|"e")("S"|"s")("A"|"a")("S"|"s")("C"|"c") ":" ("__@recordmap@___")? <IDENTIFIER> ( ( <DOT> | <MINUS> ) <IDENTIFIER> )* >
  | <INDEXVALUESDESC_IDENTIFIER: ("I"|"i")("N"|"n")("D"|"d")("E"|"e")("X"|"x")("V"|"v")("A"|"a")("L"|"l")("U"|"u")("E"|"e")("S"|"s")("D"|"d")("E"|"e")("S"|"s")("C"|"c") ":" ("__@recordmap@___")? <IDENTIFIER> ( ( <DOT> | <MINUS> ) <IDENTIFIER> )* >
  | <BUCKET_IDENTIFIER: ("B"|"b")("U"|"u")("C"|"c")("K"|"k")("E"|"e")("T"|"t") <COLON> <IDENTIFIER> >
  | <BUCKET_NUMBER_IDENTIFIER: ("B"|"b")("U"|"u")("C"|"c")("K"|"k")("E"|"e")("T"|"t") <COLON> <INTEGER_LITERAL>  >
  | <HTTP_URL: "http://" (   (~["\"","\\","\n","\r"," ",";"])
                  | ("\\"
                    ( ["n","t","b","r","f","\\","'","\"","/"]
                    | ["0"-"7"] ( ["0"-"7"] )?
                    | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                    )
                    )
                  )* >
  | <HTTPS_URL: "https://" (   (~["\"","\\","\n","\r"," ",";"])
                  | ("\\"
                    ( ["n","t","b","r","f","\\","'","\"","/"]
                    | ["0"-"7"] ( ["0"-"7"] )?
                    | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                    )
                    )
                  )* >
  | <FILE_URL: "file://" (   (~["\"","\\","\n","\r"," ",";"])
                  | ("\\"
                    ( ["n","t","b","r","f","\\","'","\"","/"]
                    | ["0"-"7"] ( ["0"-"7"] )?
                    | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                    )
                    )
                  )* >
  | <CLASSPATH_URL: "classpath://" (   (~["\"","\\","\n","\r"," ",";"])
                  | ("\\"
                    ( ["n","t","b","r","f","\\","'","\"","/"]
                    | ["0"-"7"] ( ["0"-"7"] )?
                    | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                    )
                    )
                  )* >
  | <SCHEMA_IDENTIFIER: "schema:" <IDENTIFIER>  >
  | <#LETTER:
    [  "A"-"Z",
     "_",
     "a"-"z"
    ]
  >
  | <#PART_LETTER:
    [  "0"-"9",
     "A"-"Z",
     "_",
     "a"-"z"
    ]
  >
}

Rid Rid():
{}
{
  (
    LOOKAHEAD(4)
    "#" jjtThis.bucket = PInteger() <COLON> jjtThis.position = PInteger()
    { jjtThis.legacy = true; }
    |
    LOOKAHEAD(3)
    jjtThis.bucket = PInteger() <COLON> jjtThis.position = PInteger()
    { jjtThis.legacy = true; }
    |
    (
      <LBRACE>
      (
      <RID_ATTR>
      |
      <RID_STRING>
    )
    <COLON>
    jjtThis.expression = Expression()
    <RBRACE>
    {
       jjtThis.legacy = false;
    }
   )
  )
  { return jjtThis; }
}


BucketIdentifier BucketIdentifier():
{}
{
  (
    jjtThis.bucketId = PInteger()
    |
    jjtThis.bucketName = Identifier()
  )
  { return jjtThis; }
}

/** Root productions. */
Statement Parse() :
{Statement result;}
{
  result = Statement() <EOF>
  { return result; }
}

WhereClause ParseCondition() :
{WhereClause result;}
{
  result = WhereClause() <EOF>
  { return result; }
}

Expression ParseExpression() :
{Expression result;}
{
  result = Expression() <EOF>
  { return result; }
}

List<Statement> ParseScript() :
{
  List<Statement> result = new ArrayList<Statement>();
  Statement last;
}
{
  (
    LOOKAHEAD(LockStatement())
    last = StatementSemicolon() {result.add(last);}
    |
    LOOKAHEAD(StatementSemicolon())
    last = StatementSemicolon() {result.add(last);}
    |
    last = IfStatement() {result.add(last);}
    |
    last = ForEachBlock() {result.add(last);}
    |
    last = WhileBlock() {result.add(last);}
    |
    <SEMICOLON>
  )*
  <EOF>
  { return result; }
}

java.lang.String PString():
{
Token token = null;
}
{
  (
    token = <STRING_LITERAL>
    |
    token = <RID_STRING>
  )
  { return token.image; }
}

Identifier Identifier():
{
  Token quotedToken = null;
  Token token = null;
}
{
(
  // Regular identifier
  token = <IDENTIFIER>

  // Contextual keywords - keywords that can be used as identifiers
  // These are keywords in specific contexts but are allowed as table/column names

  // Schema and DDL keywords
  | token = <TYPE>
  | token = <TYPES>
  | token = <PROPERTY>
  | token = <INDEX>
  | token = <BUCKETS>
  | token = <BUCKETSELECTIONSTRATEGY>
  | token = <DATABASE>
  | token = <SUPERTYPE>
  | token = <EXTENDS>
  | token = <HIDDEN>
  | token = <CUSTOM>
  | token = <ENGINE>
  | token = <METADATA>

  // Statement keywords that can be identifiers
  | token = <ALTER>
  | token = <DROP>
  | token = <TRUNCATE>
  | token = <REBUILD>
  | token = <EXPORT>
  | token = <IMPORT>
  | token = <CHECK>
  | token = <EXPLAIN>
  | token = <PROFILE>
  | token = <MOVE>
  | token = <BEGIN>
  | token = <COMMIT>
  | token = <ROLLBACK>
  | token = <LOCK>
  | token = <SLEEP>
  | token = <CONSOLE>

  // DML keywords
  | token = <SET>
  | token = <PUT>
  | token = <ADD>
  | token = <REMOVE>
  | token = <MERGE>
  | token = <CONTENT>
  | token = <VALUE>
  | token = <VALUES>
  | token = <RECORD>

  // Query modifiers and options
  | token = <TO>
  | token = <OF>
  | token = <OFFSET>
  | token = <IN>
  | token = <WITH>
  | token = <WITHIN>
  | token = <NEAR>
  | token = <MINDEPTH>
  | token = <ON>
  | token = <OFF>
  | token = <OPTIONAL>
  | token = <COUNT>
  | token = <EXISTS>

  // Control flow
  | token = <IF>
  | token = <ELSE>
  | token = <CONTINUE>
  | token = <FAIL>

  // Attributes and properties
  | token = <NAME>
  | token = <KEY>
  | token = <ITEM>
  | token = <ALIASES>
  | token = <ALIGN>
  | token = <EXCEPTION>
  | token = <FIND>
  | token = <ADDBUCKET>
  | token = <REMOVEBUCKET>
  | token = <FORCE>
  | token = <FORMAT>
  | token = <OPTIMIZE>
  | token = <LINK>
  | token = <INVERSE>
  | token = <GRANT>
  | token = <REVOKE>
  | token = <READ>
  | token = <EXECUTE>
  | token = <ALL>
  | token = <NONE>
  | token = <FUNCTION>
  | token = <LANGUAGE>
  | token = <PARAMETERS>
  | token = <ISOLATION>
  | token = <START>
  | token = <DEPTH_ALIAS>
  | token = <PATH_ALIAS>
  | token = <IDENTIFIED>
  | token = <RID>
  | token = <SYSTEM>
  | token = <UNIDIRECTIONAL>

  // Quoted identifier
  | quotedToken = <QUOTED_IDENTIFIER>
) {
  if(token!=null){
    jjtThis.setStringValue( token.image );
  } else {
    jjtThis.setQuotedStringValue( quotedToken.image );
  }
  return jjtThis;
  }
}

PInteger PInteger():
{
  int sign = 1;
  Token tokenVal;
}
{
  [ <MINUS> {sign = -1;} ] tokenVal = <INTEGER_LITERAL>
  {
    jjtThis.setValue(sign, tokenVal.image);
  }
  { return jjtThis; }
}

FloatingPoint FloatingPoint():
{
  String stringValue;
  Token tokenVal;
}
{
  [ <MINUS> { jjtThis.sign = -1; } ] tokenVal = <FLOATING_POINT_LITERAL> { jjtThis.stringValue = tokenVal.image; }
  { return jjtThis; }
}

PNumber PNumber():
{ PNumber result; }
{
  (
    LOOKAHEAD( PInteger() )
    result = PInteger()
    |
    LOOKAHEAD( FloatingPoint() )
    result = FloatingPoint()
  )
  { return result; }
}

Statement Statement():
{Statement result = null;}
{
  result = StatementInternal()
  [ <SEMICOLON> ]
  {return result;}
}

Statement StatementSemicolon():
{Statement result = null;}
{
  (
    LOOKAHEAD(StatementInternal())
    result = StatementInternal()
    | result = ExpressionStatement()
  )
  <SEMICOLON>
  {return result;}
}

Statement ExpressionStatement():
{}
{
  (
    jjtThis.expression = Expression()
  ) { return jjtThis; }
}

Statement StatementInternal():
{
  Statement result = null;
}
{
  (
    // Token-based dispatch - organized by first token for efficient parsing
    // Statements with unique first tokens (no LOOKAHEAD needed)
    result = SelectStatement()
    |
    result = TraverseStatement()
    |
    result = MatchStatement()
    |
    result = UpdateStatement()
    |
    result = InsertStatement()
    |
    result = MoveVertexStatement()
    |
    result = RebuildIndexStatement()
    |
    result = ExplainStatement()
    |
    result = ProfileStatement()
    |
    result = LetStatement()
    |
    result = BeginStatement()
    |
    result = CommitStatement()
    |
    result = RollbackStatement()
    |
    result = LockStatement()
    |
    result = ReturnStatement()
    |
    result = IfStatement()
    |
    result = SleepStatement()
    |
    result = ConsoleStatement()
    |
    result = ImportDatabaseStatement()
    |
    result = ExportDatabaseStatement()
    |
    result = BackupDatabaseStatement()
    |
    result = CheckDatabaseStatement()
    |
    result = AlignDatabaseStatement()
    |
    result = DefineFunctionStatement()
    |
    // Statements that share first token - use LOOKAHEAD on second/third token
    // CREATE variants (TYPE variants need LOOKAHEAD(3) to see all 3 tokens)
    LOOKAHEAD(3) result = CreateDocumentTypeStatement()
    |
    LOOKAHEAD(3) result = CreateVertexTypeStatement()
    |
    LOOKAHEAD(3) result = CreateEdgeTypeStatement()
    |
    LOOKAHEAD(2) result = CreatePropertyStatement()
    |
    LOOKAHEAD(2) result = CreateIndexStatement()
    |
    LOOKAHEAD(2) result = CreateBucketStatement()
    |
    LOOKAHEAD(2) result = CreateVertexStatement()
    |
    LOOKAHEAD(2) result = CreateEdgeStatement()
    |
    // DELETE variants
    LOOKAHEAD(2) result = DeleteFunctionStatement()
    |
    result = DeleteStatement()
    |
    // TRUNCATE variants
    LOOKAHEAD(2) result = TruncateTypeStatement()
    |
    LOOKAHEAD(2) result = TruncateBucketStatement()
    |
    LOOKAHEAD(2) result = TruncateRecordStatement()
    |
    // ALTER variants
    LOOKAHEAD(2) result = AlterTypeStatement()
    |
    LOOKAHEAD(2) result = AlterPropertyStatement()
    |
    LOOKAHEAD(2) result = AlterBucketStatement()
    |
    LOOKAHEAD(2) result = AlterDatabaseStatement()
    |
    // DROP variants
    LOOKAHEAD(2) result = DropTypeStatement()
    |
    LOOKAHEAD(2) result = DropPropertyStatement()
    |
    LOOKAHEAD(2) result = DropIndexStatement()
    |
    LOOKAHEAD(2) result = DropBucketStatement()
  )
  {
    return result;
  }
}

Statement QueryStatement():
{
 Statement result;
}
{
  (
    LOOKAHEAD( SelectStatement() )
    result = SelectStatement()
    |
    result = TraverseStatement()
    |
    result = MatchStatement()
  ){ return result; }
}

SelectStatement SelectStatement():
{}
{
  (
    <SELECT>
    [ jjtThis.projection = Projection() ]
    [
      <FROM>
      jjtThis.target = FromClause()
    ]
    [ jjtThis.letClause = LetClause() ]
    [ <WHERE> jjtThis.whereClause = WhereClause() ]
    [ jjtThis.groupBy = GroupBy() ]
    [ jjtThis.orderBy = OrderBy() ]
    [ jjtThis.unwind = Unwind() ]
    [
      jjtThis.skip = Skip() [ jjtThis.limit = Limit() ]
      |
      jjtThis.limit = Limit() [ jjtThis.skip = Skip() ]
    ]
    [ jjtThis.timeout = Timeout() ]
  )
  {
    jjtThis.validate();
    return jjtThis;
  }
}

TraverseStatement TraverseStatement():
{ TraverseProjectionItem lastProjection;}
{
  <TRAVERSE>
  [
    lastProjection = TraverseProjectionItem() { jjtThis.projections.add(lastProjection); }
    ( <COMMA> lastProjection = TraverseProjectionItem()  { jjtThis.projections.add(lastProjection); } )*
  ]
  <FROM>
  jjtThis.target = FromClause()
  [ <MAXDEPTH> jjtThis.maxDepth = PInteger() ]
  [ <WHILE> jjtThis.whileClause = WhereClause() ]
  [ jjtThis.limit = Limit() ]
  [ <STRATEGY>
    (
    <DEPTH_FIRST> { jjtThis.strategy = TraverseStatement.Strategy.DEPTH_FIRST; }
    |
    <BREADTH_FIRST> { jjtThis.strategy = TraverseStatement.Strategy.BREADTH_FIRST; }
    )
  ]
  {return jjtThis;}
}

MatchStatement MatchStatement():
{
  MatchExpression lastMatchExpr = null;
  Expression lastReturn = null;
  Identifier lastReturnAlias = null;
  NestedProjection lastNestedProjection = null;
}
{
  (
    <MATCH>
    lastMatchExpr = MatchExpression() { jjtThis.matchExpressions.add(lastMatchExpr); }
    (
      <COMMA>
      (
         lastMatchExpr = MatchExpression() { jjtThis.matchExpressions.add(lastMatchExpr); }
         |
         (
          <NOT> lastMatchExpr = MatchExpression() { jjtThis.notMatchExpressions.add(lastMatchExpr); }
         )
      )
    )*
    <RETURN>
    (
      LOOKAHEAD(2)
      <DISTINCT> { jjtThis.returnDistinct = true; }
      lastReturn = Expression() {lastReturnAlias = null;}
      [ lastNestedProjection = NestedProjection() ]
      |
      LOOKAHEAD(Expression())
      lastReturn = Expression() {lastReturnAlias = null;}
      [ lastNestedProjection = NestedProjection() ]
    )
    [ <AS> lastReturnAlias = Identifier() ]
    {
      jjtThis.returnAliases.add(lastReturnAlias);
      jjtThis.returnItems.add(lastReturn);
      jjtThis.returnNestedProjections.add(lastNestedProjection);
      lastNestedProjection = null;
    }
    (
      <COMMA>
      lastReturn = Expression() {lastReturnAlias = null;}
      [ lastNestedProjection = NestedProjection() ]
      [ <AS> lastReturnAlias = Identifier() ]
      {
        jjtThis.returnAliases.add(lastReturnAlias);
        jjtThis.returnItems.add(lastReturn);
        jjtThis.returnNestedProjections.add(lastNestedProjection);
        lastNestedProjection = null;
      }
    )*
    [ jjtThis.groupBy = GroupBy() ]
    [ jjtThis.orderBy = OrderBy() ]
    [ jjtThis.unwind = Unwind() ]
    [ jjtThis.skip = Skip() ]
    [ jjtThis.limit = Limit() ]
  ){ return jjtThis; }
}

DeleteStatement DeleteStatement():
{}
{
  <DELETE> [<VERTEX>]
  <FROM>
  jjtThis.fromClause = FromClause()
  [ <RETURN> <BEFORE> { jjtThis.returnBefore = true; } ]
  [ <WHERE> jjtThis.whereClause = WhereClause() ]
  [ jjtThis.limit = Limit() ]
  [ <UNSAFE> { jjtThis.unsafe = true; }]
  {return jjtThis;}
}

UpdateStatement UpdateStatement():
{
  UpdateOperations lastOperations;
  Rid lastRid;}
{
  <UPDATE>
  jjtThis.target = FromClause()
  ( lastOperations = UpdateOperations() { jjtThis.operations.add(lastOperations); } )+
  [ <UPSERT> { jjtThis.upsert = true; } ]
  [
    <RETURN>
    ( <BEFORE> { jjtThis.returnBefore = true; } | <AFTER> { jjtThis.returnAfter = true; } | <COUNT> { jjtThis.returnCount = true; })
    [
      jjtThis.returnProjection = Projection()
    ]
  ]
  [ <WHERE> jjtThis.whereClause = WhereClause() ]
  [ jjtThis.limit = Limit() ]
  [ jjtThis.timeout = Timeout() ]
  {return jjtThis;}
}

UpdateOperations UpdateOperations():
{
  UpdateItem lastItem;
  UpdatePutItem lastPutItem;
  UpdateIncrementItem lastIncrementItem;
  UpdateRemoveItem lastRemoveItem;
}
{
  (
    (
      <SET> { jjtThis.type = UpdateOperations.TYPE_SET; }
      lastItem = UpdateItem() { jjtThis.updateItems.add(lastItem); }
      (
        <COMMA> lastItem = UpdateItem() { jjtThis.updateItems.add(lastItem); }
      )*
    )
    |
    (
      <PUT> { jjtThis.type = UpdateOperations.TYPE_PUT; }
      lastPutItem = UpdatePutItem()  { jjtThis.updatePutItems.add(lastPutItem); }
      (
        <COMMA> lastPutItem = UpdatePutItem()  { jjtThis.updatePutItems.add(lastPutItem); }
      )*
    )
    |
    (
      (
        <MERGE> { jjtThis.type = UpdateOperations.TYPE_MERGE; }
        |
        <CONTENT> { jjtThis.type = UpdateOperations.TYPE_CONTENT; }
      )
      jjtThis.json = Json()
    )
    |
    (
      (
        <INCREMENT> { jjtThis.type = UpdateOperations.TYPE_INCREMENT; }
        |
        <ADD> { jjtThis.type = UpdateOperations.TYPE_ADD; }
      )
      lastIncrementItem = UpdateIncrementItem() { jjtThis.updateIncrementItems.add(lastIncrementItem); }
      (
        <COMMA> lastIncrementItem = UpdateIncrementItem() { jjtThis.updateIncrementItems.add(lastIncrementItem); }
      )*
     )
     |
     (
      <REMOVE> { jjtThis.type = UpdateOperations.TYPE_REMOVE; }
      lastRemoveItem = UpdateRemoveItem()  { jjtThis.updateRemoveItems.add(lastRemoveItem); }
      (
        <COMMA>
        lastRemoveItem = UpdateRemoveItem()  { jjtThis.updateRemoveItems.add(lastRemoveItem); }
      )*
     )
  )
  { return jjtThis; }
}

UpdateItem UpdateItem():
{}
{
  jjtThis.left = Identifier()
  [ jjtThis.leftModifier = Modifier() ]
  (
    <EQ> { jjtThis.operator = UpdateItem.OPERATOR_EQ; }
    |
    <PLUSASSIGN> { jjtThis.operator = UpdateItem.OPERATOR_PLUSASSIGN; }
    |
    <MINUSASSIGN> { jjtThis.operator = UpdateItem.OPERATOR_MINUSASSIGN; }
    |
    <STARASSIGN> { jjtThis.operator = UpdateItem.OPERATOR_STARASSIGN; }
    |
    <SLASHASSIGN> { jjtThis.operator = UpdateItem.OPERATOR_SLASHASSIGN; }
  )
  jjtThis.right = Expression()
  { return jjtThis; }
}

UpdateIncrementItem UpdateIncrementItem():
{}
{
  jjtThis.left = Identifier()
  [ jjtThis.leftModifier = Modifier() ]
  <EQ>
  jjtThis.right = Expression()
  { return jjtThis; }
}

UpdateRemoveItem UpdateRemoveItem():
{}
{
  jjtThis.left = Expression() [ <EQ> jjtThis.right = Expression() ]
  { return jjtThis; }
}

UpdatePutItem UpdatePutItem():
{}
{
  jjtThis.left = Identifier() <EQ> jjtThis.key = Expression() <COMMA> jjtThis.value = Expression()
  { return jjtThis; }
}


UpdateAddItem UpdateAddItem():
{}
{
  jjtThis.left = Identifier() <EQ>
  jjtThis.right = Expression()
  { return jjtThis; }
}

InsertStatement InsertStatement():
{}
{
(
  <INSERT> <INTO>
  (
    jjtThis.targetType = Identifier() [<BUCKET> jjtThis.targetBucketName = Identifier()]
    |
    jjtThis.targetBucket = Bucket()
  )
  [ LOOKAHEAD(InsertBody()) jjtThis.insertBody = InsertBody() ]
  [ <RETURN> jjtThis.returnStatement = Projection() ]
  [
    [ <FROM> { jjtThis.selectWithFrom = true; } ]
    (
       jjtThis.selectStatement = SelectStatement()
       |
       LOOKAHEAD(2)
      (
        <LPAREN>
        jjtThis.selectStatement = SelectStatement()
        { jjtThis.selectInParentheses = true; }
        <RPAREN>
      )
    )
  ]
  [ <UNSAFE> { jjtThis.unsafe = true; }]
) {return jjtThis;}
}

InsertBody InsertBody():
{
  Identifier lastIdentifier;
  Expression lastExpression;
  List<Expression> lastExpressionList;
}
{
  (
    (
      LOOKAHEAD(3)
      <LPAREN>
      lastIdentifier = Identifier()
      {
        jjtThis.identifierList = new ArrayList<Identifier>();
        jjtThis.identifierList.add(lastIdentifier);
      }
      (
        <COMMA>
        lastIdentifier = Identifier() { jjtThis.identifierList.add(lastIdentifier); }
      )*
      <RPAREN>
      <VALUES>
      <LPAREN>
      {
        jjtThis.valueExpressions = new ArrayList<List<Expression>>();
        lastExpressionList = new ArrayList<Expression>();
        jjtThis.valueExpressions.add(lastExpressionList);
      }
      lastExpression = Expression() { lastExpressionList.add(lastExpression); }
      (
        <COMMA>
        lastExpression = Expression() { lastExpressionList.add(lastExpression); }
      )*
      <RPAREN>
      (
        <COMMA>
        <LPAREN>
        {
          lastExpressionList = new ArrayList<Expression>();
          jjtThis.valueExpressions.add(lastExpressionList);
        }
        lastExpression = Expression() { lastExpressionList.add(lastExpression); }
        (
          <COMMA>
          lastExpression = Expression() { lastExpressionList.add(lastExpression); }
        )*
        <RPAREN>
      )*
      |
      LOOKAHEAD(3)
      <SET>
      {
        jjtThis.setExpressions = new ArrayList<InsertSetExpression>();
        InsertSetExpression lastSetExpr = new InsertSetExpression();
        jjtThis.setExpressions.add(lastSetExpr);
      }
      lastSetExpr.left = Identifier() <EQ> lastSetExpr.right = Expression()

      (
        <COMMA>
        {
           lastSetExpr = new InsertSetExpression();
           jjtThis.setExpressions.add(lastSetExpr);
        }
        lastSetExpr.left = Identifier() <EQ> lastSetExpr.right = Expression()
      )*
      |
      ( <CONTENT>
         (
           jjtThis.contentArray = JsonArray()
           |
           jjtThis.contentJson = Json()
           |
           jjtThis.contentInputParam = InputParameter()
         )
      )
     )
  )
  { return jjtThis; }
}

CreateVertexStatement CreateVertexStatement():
{}
{
  <CREATE> <VERTEX>
  [
    // Optional target: type+bucket or just bucket
    LOOKAHEAD(2)
    (
      LOOKAHEAD( Bucket() )
      jjtThis.targetBucket = Bucket()
      |
      jjtThis.targetType = Identifier()
      [
        <BUCKET>
        jjtThis.targetBucketName = Identifier()
      ]
    )
  ]
  [ <RETURN> jjtThis.returnStatement = Projection() ]
  [ LOOKAHEAD(InsertBody()) jjtThis.insertBody = InsertBody() ]
  {return jjtThis;}
}

MoveVertexStatement MoveVertexStatement():
{ Expression lastSetExpr; }
{
  (
     <MOVE> <VERTEX>
     jjtThis.source = FromItem()
     <TO>
     (
        jjtThis.targetBucket = Bucket()
        |
        (
          <TYPE>
          <COLON>
          jjtThis.targetType = Identifier()
        )
     )
     [ jjtThis.updateOperations = UpdateOperations() ]
     [ jjtThis.batch = Batch() ]
  ){ return jjtThis; }
}

CreateEdgeStatement CreateEdgeStatement():
{
  Rid lastRid;
}
{
  <CREATE> <EDGE>
  [ jjtThis.targetType = Identifier() [<BUCKET> jjtThis.targetBucketName = Identifier()]]
  <FROM>
  (
    jjtThis.leftExpression = Expression()
  )
  <TO>
  (
    jjtThis.rightExpression = Expression()
  )
  [ <UNIDIRECTIONAL> { jjtThis.unidirectional = true; }]
  [ <IF> <NOT> <EXISTS> { jjtThis.ifNotExists = true; }]
  [ jjtThis.body = InsertBody() ]
  {return jjtThis;}
}

InputParameter InputParameter():
{ InputParameter result; }
{
  (
    result = PositionalParameter()
    |
    result = NamedParameter()
  )
  { return result; }
}

PositionalParameter PositionalParameter():
{}
{
  <HOOK>
  {
    jjtThis.paramNumber = inputParamCount;
    inputParamCount++;
    return jjtThis;
  }
}

NamedParameter NamedParameter():
{
Identifier identifierParam;
Token token;
}
{
  <COLON>
  (
    identifierParam = Identifier() { jjtThis.paramName = identifierParam.toString(); }
    |
    token = <SKIP2> {jjtThis.paramName = token.image;}
    |
    token = <LIMIT> {jjtThis.paramName = token.image;}
    |
    token = <FROM> {jjtThis.paramName = token.image;}
  )
  {
   jjtThis.paramNumber = inputParamCount;
   inputParamCount++;
   return jjtThis;
  }
}

Projection Projection():
{
  java.util.List<ProjectionItem> items = new java.util.ArrayList<ProjectionItem>();
  ProjectionItem lastItem = null;
}
{
  (
    LOOKAHEAD(ProjectionItem())
    lastItem = ProjectionItem() {items.add(lastItem);} ("," lastItem = ProjectionItem() {items.add(lastItem);} )*
    |
    (
      <DISTINCT> { jjtThis.distinct = true; }
      lastItem = ProjectionItem() {items.add(lastItem);} ("," lastItem = ProjectionItem() {items.add(lastItem);} )*
    )
  )
  {
    jjtThis.items = items;
    return jjtThis;
  }
}

ProjectionItem ProjectionItem():
{}
{
  [<BANG> {jjtThis.exclude = true;}]
  jjtThis.expression = Expression()
  [ jjtThis.nestedProjection = NestedProjection() ]
  [ <AS> jjtThis.alias = Alias() ]
  {return jjtThis;}
}

NestedProjection NestedProjection():
{
  NestedProjectionItem lastItem;
}
{
  <COLON> <LBRACE>
  lastItem = NestedProjectionItem() {
     if(lastItem.exclude) {
     jjtThis.excludeItems.add(lastItem);
     } else if(lastItem.star) {
     jjtThis.starItem = lastItem;
     } else {
     jjtThis.includeItems.add(lastItem);
     }
  }
  (
    <COMMA>
     lastItem = NestedProjectionItem() {
      if(lastItem.exclude) {
        jjtThis.excludeItems.add(lastItem);
      } else if(lastItem.star) {
        jjtThis.starItem = lastItem;
      } else {
        jjtThis.includeItems.add(lastItem);
      }
     }
  )*
  <RBRACE> { return jjtThis;}
}

NestedProjectionItem NestedProjectionItem():
{}
{
  (
    LOOKAHEAD(1)
    <STAR> { jjtThis.star = true; }
    |
    (
    [<BANG> {jjtThis.exclude = true;} ]
    jjtThis.expression = Expression()
    [<STAR> {jjtThis.rightWildcard = true;} ]
    )
  )
  [jjtThis.expansion = NestedProjection() ]
  [<AS> jjtThis.alias = Identifier()] {return jjtThis;}
}

ArraySelector ArraySelector():
{}
{
  (
    LOOKAHEAD( Rid() )
    jjtThis.rid = Rid()
    |
    LOOKAHEAD( InputParameter() )
    jjtThis.inputParam = InputParameter()
    |
    LOOKAHEAD( Expression() )
    jjtThis.expression = Expression()
  )
  { return jjtThis; }
}

ArrayNumberSelector ArrayNumberSelector():
{ Token tokenVal; }
{
  (
    LOOKAHEAD( InputParameter() )
    jjtThis.inputValue = InputParameter()
    |
    LOOKAHEAD( PInteger() )
    tokenVal = <INTEGER_LITERAL> { jjtThis.integer = Integer.parseInt(tokenVal.image); }
  )
  { return jjtThis; }
}

ArraySingleValuesSelector ArraySingleValuesSelector():
{ ArraySelector lastSelector; }
{
  lastSelector = ArraySelector() { jjtThis.items.add(lastSelector); }
  ( <COMMA> lastSelector = ArraySelector() { jjtThis.items.add(lastSelector); } ) *
  { return jjtThis; }
}

ArrayRangeSelector ArrayRangeSelector():
{ Token token; }
{
  (
    (
      token = <INTEGER_RANGE>
      {
        String img = token.image;
        String[] splitted = img.split("\\.\\.");
        jjtThis.from = Integer.parseInt(splitted[0], 10);
        jjtThis.to = Integer.parseInt(splitted[1], 10);
        jjtThis.newRange = true;
      }
    )
    |
    (
      token = <ELLIPSIS_INTEGER_RANGE>
      {
        String img2 = token.image;
        String[] splitted2 = img2.split("\\.\\.\\.");
        jjtThis.from = Integer.parseInt(splitted2[0], 10);
        jjtThis.to = Integer.parseInt(splitted2[1], 10);
        jjtThis.newRange = true;
        jjtThis.included = true;
      }
    )
    |
    (
      jjtThis.fromSelector = ArrayNumberSelector()
      (
        (<RANGE> {jjtThis.newRange = true;})
        |
        (<ELLIPSIS> {jjtThis.newRange = true; jjtThis.included = true;})
      )
      jjtThis.toSelector = ArrayNumberSelector()
    )
  )
  { return jjtThis; }
}


Identifier Alias():
{
  Identifier identifier;
}
{
  identifier = Identifier()
  {return identifier;}
}

RecordAttribute RecordAttribute():
{ Token token; }
{
  token = <RECORD_ATTRIBUTE> { jjtThis.name = token.image; }
  { return jjtThis; }
}

FunctionCall FunctionCall():
{
  Expression lastExpression = null;
}
{
  (
    (  jjtThis.name = Identifier() )
    |
    ( <DISTINCT> { jjtThis.name = new Identifier("distinct"); } )
  )
  <LPAREN>
  (
    [
      lastExpression = Expression() {jjtThis.params.add(lastExpression);} ( <COMMA> lastExpression = Expression() {jjtThis.params.add(lastExpression);})*
    ]
  )
  <RPAREN>
  { return jjtThis; }
}

MethodCall MethodCall():
{ Expression lastExpression; }
{
  <DOT> jjtThis.methodName = Identifier()
  <LPAREN> [
    lastExpression = Expression() { jjtThis.params.add(lastExpression); }
    ( <COMMA> lastExpression = Expression() { jjtThis.params.add(lastExpression); } )*
  ] <RPAREN>
  { return jjtThis; }
}

LevelZeroIdentifier LevelZeroIdentifier():
{}
{
  (
    LOOKAHEAD( FunctionCall() )
    jjtThis.functionCall = FunctionCall()
    |
    <THIS> { jjtThis.self = true; }
    |
    LOOKAHEAD( PCollection() )
    jjtThis.collection = PCollection()
  )
  { return jjtThis; }
}

SuffixIdentifier SuffixIdentifier():
{}
{
  (
    LOOKAHEAD( Identifier() )
    jjtThis.identifier = Identifier()
    |
    LOOKAHEAD( RecordAttribute() )
    jjtThis.recordAttribute = RecordAttribute()
    |
    ( <STAR> { jjtThis.star = true; } )
  )
  { return jjtThis; }
}


BaseIdentifier BaseIdentifier():
{}
{
  (
    LOOKAHEAD( LevelZeroIdentifier() )
    jjtThis.levelZero = LevelZeroIdentifier()
    |
    LOOKAHEAD( SuffixIdentifier() )
    jjtThis.suffix = SuffixIdentifier()
  )
  { return jjtThis; }
}

Modifier Modifier():
{}
{
  (
    (
      <LBRACKET> { jjtThis.squareBrackets = true; }
      (
        LOOKAHEAD( RightBinaryCondition() )
        jjtThis.rightBinaryCondition = RightBinaryCondition()
        |
        LOOKAHEAD( ArrayRangeSelector() )
        jjtThis.arrayRange = ArrayRangeSelector()
        |
        LOOKAHEAD( OrBlock() )
        jjtThis.condition = OrBlock()
        |
        LOOKAHEAD( ArraySingleValuesSelector() )
        jjtThis.arraySingleValues = ArraySingleValuesSelector()

      )
      <RBRACKET>
    )
       |
       LOOKAHEAD( MethodCall() )
       jjtThis.methodCall = MethodCall()
       |
    <DOT> jjtThis.suffix = SuffixIdentifier()
  )
  [
    LOOKAHEAD( Modifier() )
    jjtThis.next = Modifier()
  ]
  { return jjtThis; }
}

Expression Expression():
{Token token; }
{
  (
    LOOKAHEAD( ArrayConcatExpression() )
    jjtThis.arrayConcatExpression = ArrayConcatExpression() { jjtThis.value = jjtThis.arrayConcatExpression; }
    |
    LOOKAHEAD(2) <NULL> {jjtThis.isNull = true; jjtThis.value = null;}
    |
    <TRUE> { jjtThis.booleanValue = true; jjtThis.value = true; }
    |
    <FALSE> { jjtThis.booleanValue = false; jjtThis.value = false; }
    |
    LOOKAHEAD( Rid() )
    jjtThis.rid = Rid() { jjtThis.value = jjtThis.rid; }
    |
    LOOKAHEAD( <LPAREN> WhereClause() <RPAREN> )
    <LPAREN>
      jjtThis.whereCondition = WhereClause() {jjtThis.value = jjtThis.whereCondition; }
    <RPAREN>
    |
    LOOKAHEAD( MathExpression() )
    jjtThis.mathExpression = MathExpression() { jjtThis.value = jjtThis.mathExpression; }
    |
    jjtThis.json = Json() {jjtThis.value = jjtThis.json; }
  )
  { return jjtThis; }
}

ArrayConcatExpression ArrayConcatExpression():
{
  ArrayConcatExpressionElement sub;
  jjtThis.setChildExpressions(new java.util.ArrayList());
}
{
  sub = ArrayConcatExpressionElement() { jjtThis.getChildExpressions().add(sub); }
  (
    <SC_OR>
    sub = ArrayConcatExpressionElement() { jjtThis.getChildExpressions().add(sub); }
  )+
  {
    return jjtThis;
  }
}

ArrayConcatExpressionElement ArrayConcatExpressionElement():
{Token token; }
{
  (
    LOOKAHEAD(2) <NULL> {jjtThis.isNull = true; jjtThis.value = null;}
    |
    <TRUE> { jjtThis.booleanValue = true; jjtThis.value = true; }
    |
    <FALSE> { jjtThis.booleanValue = false; jjtThis.value = false; }
    |
    LOOKAHEAD( Rid() )
    jjtThis.rid = Rid() { jjtThis.value = jjtThis.rid; }
    |
    LOOKAHEAD( MathExpression() )
    jjtThis.mathExpression = MathExpression() { jjtThis.value = jjtThis.mathExpression; }
    |
    jjtThis.json = Json() {jjtThis.value = jjtThis.json; }

  )
  [ jjtThis.nestedProjection = NestedProjection() ]
  { return jjtThis; }
}

MathExpression MathExpression():
{
  MathExpression sub;
  jjtThis.setChildExpressions(new java.util.ArrayList());
}
{
  sub = FirstLevelExpression() { jjtThis.getChildExpressions().add(sub); }
  (
    LOOKAHEAD( 2 )
    (
      <STAR> { jjtThis.operators.add( MathExpression.Operator.STAR); }
      |
      <SLASH> { jjtThis.operators.add( MathExpression.Operator.SLASH); }
      |
      <REM> { jjtThis.operators.add( MathExpression.Operator.REM); }
      |
      <PLUS> { jjtThis.operators.add( MathExpression.Operator.PLUS); }
      |
      <MINUS> { jjtThis.operators.add(MathExpression.Operator.MINUS); }
      |
      <LSHIFT> { jjtThis.operators.add(MathExpression.Operator.LSHIFT); }
      |
      <RSHIFT> { jjtThis.operators.add(MathExpression.Operator.RSHIFT); }
      |
      <RUNSIGNEDSHIFT> { jjtThis.operators.add(MathExpression.Operator.RUNSIGNEDSHIFT); }
      |
      <BIT_AND> { jjtThis.operators.add(MathExpression.Operator.BIT_AND); }
      |
      <BIT_OR> { jjtThis.operators.add(MathExpression.Operator.BIT_OR); }
      |
      <XOR> { jjtThis.operators.add(MathExpression.Operator.XOR); }
    )
    sub = FirstLevelExpression() { jjtThis.getChildExpressions().add(sub); }
  )*
  {
    if(jjtThis.getChildExpressions().size() != 1){
      return jjtThis;
    } else {
      return jjtThis.getChildExpressions().get(0);
    }
  }
}

MathExpression FirstLevelExpression():
{ MathExpression expr;}
{
  (
    LOOKAHEAD( <LPAREN> )
    expr = ParenthesisExpression()
    |
    expr = BaseExpression()
  )
  {return expr;}
}

MathExpression ParenthesisExpression():
{}
{
  <LPAREN>
  (
    LOOKAHEAD( <SELECT> | <TRAVERSE> | <MATCH> | <INSERT> )
    (
      jjtThis.statement = QueryStatement()
      |
      jjtThis.statement = InsertStatement()
    )
    |
    jjtThis.expression = Expression()
)
  <RPAREN>
  {return jjtThis;}
}

BaseExpression BaseExpression():
{}
{
  (
    jjtThis.number = PNumber()
    |
    (
      jjtThis.identifier = BaseIdentifier()
      [
        LOOKAHEAD( Modifier() )
        jjtThis.modifier = Modifier()
      ]
    )
    |
    (
      jjtThis.inputParam = InputParameter()
      [
        LOOKAHEAD( Modifier() )
        jjtThis.modifier = Modifier()
      ]
    )
    |
    (
      (
        jjtThis.string = PString()
        |
        token = <CHARACTER_LITERAL> { jjtThis.string = token.image; }
      )
      [
        LOOKAHEAD( Modifier() )
        jjtThis.modifier = Modifier()
      ]
    )
    |
    <NULL> { jjtThis.isNull = true; }
  )
  {return jjtThis;}
}

FromClause FromClause():
{}
{
  jjtThis.item = FromItem()
  { return jjtThis; }
}

LetClause LetClause():
{
  LetItem lastItem;
}
{
  <LET> lastItem = LetItem() { jjtThis.items.add(lastItem); } ( <COMMA> lastItem = LetItem() { jjtThis.items.add(lastItem); } )*
  { return jjtThis; }
}

LetItem LetItem():
{ }
{
  jjtThis.varName = Identifier() <EQ>
  (
    LOOKAHEAD( Expression() )
    jjtThis.expression = Expression()
    |
    (
      <LPAREN>
      (
        jjtThis.query = QueryStatement()
      )
      <RPAREN>
    )
  )
  { return jjtThis; }
}

FromItem FromItem():
{
  jjtThis.rids = new java.util.ArrayList();
  jjtThis.inputParams = new java.util.ArrayList();
  Rid lastRid;
  InputParameter lastParam;
}
{
  (
    lastRid = Rid() { jjtThis.rids.add(lastRid); }
    |
    LOOKAHEAD(2)
    <LBRACKET> lastRid = Rid() { jjtThis.rids.add(lastRid); }
    (
      <COMMA> lastRid = Rid() { jjtThis.rids.add(lastRid); }
    )* <RBRACKET>
    |
    (
      <LBRACKET>
      (
        lastParam = PositionalParameter() { jjtThis.inputParams.add(lastParam); }
        |
        lastParam = NamedParameter() { jjtThis.inputParams.add(lastParam); }
      )
      (
        <COMMA>
        lastParam = PositionalParameter() { jjtThis.inputParams.add(lastParam); }
        |
        lastParam = NamedParameter() { jjtThis.inputParams.add(lastParam); }
      )* <RBRACKET>
    )
    |
    jjtThis.bucket = Bucket()
    |
    jjtThis.bucketList = BucketList()
    |
    LOOKAHEAD(IndexIdentifier())
    jjtThis.index = IndexIdentifier()
    |
    jjtThis.schema = SchemaIdentifier()
    |
    (
      <LPAREN> jjtThis.statement = QueryStatement() <RPAREN>
      [
        LOOKAHEAD( Modifier() )
        jjtThis.modifier = Modifier()
      ]
    )
    |
    jjtThis.inputParam = InputParameter()
    |
    LOOKAHEAD(2)
    jjtThis.functionCall = FunctionCall()
    [
      LOOKAHEAD( Modifier() )
      jjtThis.modifier = Modifier()
    ]
    |
    (
      jjtThis.identifier = Identifier()
      [
        LOOKAHEAD( Modifier() )
        jjtThis.modifier = Modifier()
      ]
    )

  )
  { return jjtThis; }
}

Bucket Bucket():
{ Token cName; }
{
  (
    cName = <BUCKET_IDENTIFIER> {jjtThis.bucketName = cName.image.split(":")[1];}
    |
    cName = <BUCKET_NUMBER_IDENTIFIER> {jjtThis.bucketNumber = Integer.parseInt(cName.image.split(":")[1]);}
  )
  { return jjtThis; }
}

BucketList BucketList():
{ Identifier lastIdentifier; }
{
  <BUCKET> <COLON> <LBRACKET>
  [
   lastIdentifier = Identifier() { jjtThis.buckets.add(lastIdentifier); }
   ( <COMMA> lastIdentifier = Identifier() { jjtThis.buckets.add(lastIdentifier); } )*
  ]
  <RBRACKET>
  { return jjtThis; }
}

SchemaIdentifier SchemaIdentifier():
{ Token mdName; }
{
  mdName = <SCHEMA_IDENTIFIER> {jjtThis.name = mdName.image.split(":")[1];}
  { return jjtThis; }
}

IndexIdentifier IndexIdentifier():
{
  Token token;
}
{
  (
    (
      <INDEX_COLON>
      jjtThis.indexName = Identifier() { jjtThis.type = IndexIdentifier.Type.INDEX; }
    )
    |
    (
      (
        token = <INDEXVALUES_IDENTIFIER> { jjtThis.type = IndexIdentifier.Type.VALUES; }
        |
        token = <INDEXVALUESASC_IDENTIFIER> { jjtThis.type = IndexIdentifier.Type.VALUESASC; }
        |
        token = <INDEXVALUESDESC_IDENTIFIER> { jjtThis.type = IndexIdentifier.Type.VALUESDESC; }
      )
      {
        jjtThis.indexNameString = token.image.split(":")[1];
      }
    )
  )
  { return jjtThis; }
}

WhereClause WhereClause():
{}
{
  jjtThis.baseExpression = OrBlock()
  {return jjtThis;}
}

OrBlock OrBlock():
{ AndBlock lastAnd = null; }
{
  lastAnd = AndBlock() { jjtThis.getSubBlocks().add(lastAnd); }
  (
    <OR>
    {
      // Validate that we have a proper condition after OR
      if (getToken(1).kind == AND || getToken(1).kind == OR ||
          getToken(1).kind == EOF || getToken(1).kind == RPAREN ||
          getToken(1).kind == RBRACE || getToken(1).kind == SEMICOLON) {
        throw new ParseException("Syntax error: OR operator at line " + token.beginLine +
          ", column " + token.beginColumn + " must be followed by a condition, not '" +
          getToken(1).image + "'");
      }
    }
    lastAnd = AndBlock() { jjtThis.getSubBlocks().add(lastAnd); }
  )*
  { return jjtThis; }
}

AndBlock AndBlock():
{NotBlock lastNot = null; }
{
  lastNot = NotBlock() { jjtThis.getSubBlocks().add(lastNot); }
  (
    <AND>
    {
      // Validate that we have a proper condition after AND
      if (getToken(1).kind == AND || getToken(1).kind == OR ||
          getToken(1).kind == EOF || getToken(1).kind == RPAREN ||
          getToken(1).kind == RBRACE || getToken(1).kind == SEMICOLON) {
        throw new ParseException("Syntax error: AND operator at line " + token.beginLine +
          ", column " + token.beginColumn + " must be followed by a condition, not '" +
          getToken(1).image + "'");
      }
    }
    lastNot = NotBlock() { jjtThis.getSubBlocks().add(lastNot); }
  )*
  { return jjtThis; }
}

NotBlock NotBlock():
{}
{
(
  (
    <NOT> {jjtThis.negate = true;}
    (
      LOOKAHEAD(ParenthesisBlock())
      jjtThis.sub = ParenthesisBlock()
      |
      jjtThis.sub = ConditionBlock()
    )
  )
  |
  (
    LOOKAHEAD(ParenthesisBlock())
    jjtThis.sub = ParenthesisBlock()
    |
    jjtThis.sub = ConditionBlock()
  )
) { return jjtThis; }
}

BooleanExpression ParenthesisBlock():
{}
{
  <LPAREN> jjtThis.subElement = OrBlock() <RPAREN>
  { return jjtThis; }
}

BooleanExpression ConditionBlock():
{BooleanExpression result = null;}
{
(
  <TRUE> { result = BooleanExpression.TRUE;}
  |
  <FALSE> { result = BooleanExpression.FALSE;}
  |
  <NULL> { result =null;}
  |
  LOOKAHEAD(IsNotNullCondition())
  result = IsNotNullCondition()
  |
  LOOKAHEAD(IsNullCondition())
  result = IsNullCondition()
  |
  LOOKAHEAD(IsNotDefinedCondition())
  result = IsNotDefinedCondition()
  |
  LOOKAHEAD(IsDefinedCondition())
  result = IsDefinedCondition()
  |
  LOOKAHEAD(NotInCondition())
  result = NotInCondition()
  |
  LOOKAHEAD(InCondition())
  result = InCondition()
  |
  LOOKAHEAD(BetweenCondition())
  result = BetweenCondition()
  |
  LOOKAHEAD(ContainsCondition())
  result = ContainsCondition()
  |
  LOOKAHEAD(ContainsValueCondition())
  result = ContainsValueCondition()
  |
  LOOKAHEAD(ContainsAllCondition())
  result = ContainsAllCondition()
  |
  LOOKAHEAD(ContainsAnyCondition())
  result = ContainsAnyCondition()
  |
  LOOKAHEAD(ContainsTextCondition())
  result = ContainsTextCondition()
  |
  LOOKAHEAD(MatchesCondition())
  result = MatchesCondition()
  |
  LOOKAHEAD(IndexMatchCondition())
  result = IndexMatchCondition()
  |
  LOOKAHEAD(InstanceofCondition())
  result = InstanceofCondition()
  |
  result = BinaryCondition()
){ return result; }
}

BinaryCompareOperator CompareOperator() #void:
{ BinaryCompareOperator result; }
{
  (
    <EQ> { jjtThis.doubleEquals = false; result = jjtThis; } #EqualsCompareOperator
    |
    <EQEQ> { jjtThis.doubleEquals = true; result = jjtThis; } #EqualsCompareOperator
    |
    <NSEQ> { result = jjtThis; } #NullSafeEqualsCompareOperator
    |
    <LT> { result = jjtThis; } #LtOperator
    |
    <GT> { result = jjtThis; } #GtOperator
    |
    <NE> { result = jjtThis; } #NeOperator
    |
    <NEQ> { result = jjtThis; } #NeqOperator
    |
    <GE> { result = jjtThis; } #GeOperator
    |
    <LE> { result = jjtThis; } #LeOperator
    |
    <LIKE> { result = jjtThis; } #LikeOperator
    |
    <ILIKE> { result = jjtThis; } #ILikeOperator
    |
    <CONTAINSKEY> { result = jjtThis; } #ContainsKeyOperator
    |
    <NEAR> { result = jjtThis; } #NearOperator
    |
    <WITHIN> { result = jjtThis; } #WithinOperator
  )
  { return result; }
}

ContainsValueOperator ContainsValueOperator():
{}
{
  <CONTAINSVALUE> {return jjtThis;}
}


RightBinaryCondition RightBinaryCondition():
{}
{
  (
     (
      jjtThis.operator = CompareOperator()
      jjtThis.right = Expression()
     )
     |
     (
     [ <NOT> { jjtThis.not = true; } ]
     jjtThis.inOperator = InOperator()
     jjtThis.right = Expression()
     )
  )
  { return jjtThis; }
}

BooleanExpression BinaryCondition():
{}
{
  jjtThis.left = Expression()
  jjtThis.operator = CompareOperator()
  jjtThis.right = Expression()
  {return jjtThis;}
}

BooleanExpression ContainsValueCondition():
{}
{
  jjtThis.left = Expression()
  jjtThis.operator = ContainsValueOperator()
  (
    LOOKAHEAD( 3 )
    <LPAREN> jjtThis.condition = OrBlock() <RPAREN>
    |
    LOOKAHEAD( Expression() )
    jjtThis.expression = Expression()
  ) { return jjtThis;}
}

BooleanExpression InstanceofCondition():
{
  Token token;
}
{
  jjtThis.left = Expression() <INSTANCEOF> (
   jjtThis.right = Identifier()
   |
   jjtThis.rightString = PString()
   |
   token = <CHARACTER_LITERAL> { jjtThis.rightString = token.image; }
  )
  {return jjtThis;}
}

BooleanExpression IndexMatchCondition():
{
  Token token;
  jjtThis.leftExpressions = new ArrayList();
  Expression lastExpression;
}
{
  <KEY>
  (
    (
      jjtThis.operator = CompareOperator() <LBRACKET>
      [
      lastExpression = Expression() { jjtThis.leftExpressions.add(lastExpression); }
      ( <COMMA>
      lastExpression = Expression() { jjtThis.leftExpressions.add(lastExpression); }
      )*
      ]
      <RBRACKET>
    )
    |
    (
    <BETWEEN> {jjtThis.between = true;} <LBRACKET>
    [
    lastExpression = Expression() { jjtThis.leftExpressions.add(lastExpression); }
    (
    <COMMA>
    lastExpression = Expression() { jjtThis.leftExpressions.add(lastExpression); }
    )*
    ]
    <RBRACKET> <AND> <LBRACKET>
    [
    lastExpression = Expression() { jjtThis.rightExpressions.add(lastExpression); }
    (
    <COMMA>
    lastExpression = Expression() { jjtThis.rightExpressions.add(lastExpression); }
    )*
    ] <RBRACKET>
    )
  )
  {return jjtThis;}
}

BooleanExpression BetweenCondition():
{}
{
  jjtThis.first = Expression() <BETWEEN>
  jjtThis.second = Expression() <AND>
  jjtThis.third = Expression()
  {return jjtThis;}
}

BooleanExpression IsNullCondition():
{}
{
  jjtThis.expression = Expression() <IS> <NULL>
  {return jjtThis;}
}

BooleanExpression IsNotNullCondition():
{}
{
  jjtThis.expression = Expression() <IS> <NOT> <NULL>
  {return jjtThis;}
}

BooleanExpression IsDefinedCondition():
{}
{
  jjtThis.expression = Expression() <IS> <DEFINED>
  {return jjtThis;}
}

BooleanExpression IsNotDefinedCondition():
{}
{
  jjtThis.expression = Expression() <IS> <NOT> <DEFINED>
  {return jjtThis;}
}

BooleanExpression ContainsCondition():
{}
{
  jjtThis.left = Expression() <CONTAINS>
  (
    LOOKAHEAD( 3 )
    ( <LPAREN> jjtThis.condition = OrBlock() <RPAREN> )
    |
    LOOKAHEAD( Expression() )
    jjtThis.right = Expression()
  )
  {return jjtThis;}
}

InOperator InOperator():
{}
{
  <IN>
  {return jjtThis;}
}

BooleanExpression InCondition():
{
  Expression lastExpression;
}
{
  jjtThis.left = Expression()
  jjtThis.operator = InOperator()
  (
    LOOKAHEAD(2)
    ( <LPAREN>
      jjtThis.rightStatement = SelectStatement()
      <RPAREN>
    )
    |
    LOOKAHEAD(2)
    ( <LPAREN> jjtThis.rightParam = InputParameter() <RPAREN>)
    |
    jjtThis.rightMathExpression = MathExpression()
  )
  {return jjtThis;}
}

BooleanExpression NotInCondition():
{
  Expression lastExpression;
}
{
  jjtThis.left = Expression() <NOT> InOperator()
  (
    LOOKAHEAD(2)
    ( <LPAREN>
    jjtThis.rightStatement = SelectStatement()
    <RPAREN>
    )
    |
    LOOKAHEAD(2)
    ( <LPAREN> jjtThis.rightParam = InputParameter() <RPAREN>)
    |
    jjtThis.rightMathExpression = MathExpression()
  )
  {return jjtThis;}
}

BooleanExpression ContainsAllCondition():
{}
{
  jjtThis.left = Expression()
  <CONTAINSALL>
  (
    LOOKAHEAD( 3 )
    ( <LPAREN> jjtThis.rightBlock = OrBlock() <RPAREN> )
    |
    LOOKAHEAD( Expression() )
    jjtThis.right = Expression()
)
  {return jjtThis;}
}

BooleanExpression ContainsAnyCondition():
{}
{
  jjtThis.left = Expression()
  <CONTAINSANY>
  (
    LOOKAHEAD( 3 )
    ( <LPAREN> jjtThis.rightBlock = OrBlock() <RPAREN> )
    |
    LOOKAHEAD( Expression() )
    jjtThis.right = Expression()
)
  {return jjtThis;}
}

BooleanExpression ContainsTextCondition():
{}
{
  jjtThis.left = Expression() <CONTAINSTEXT> jjtThis.right = Expression()
  {return jjtThis;}
}

BooleanExpression MatchesCondition():
{Token token;}
{
  jjtThis.expression = Expression() <MATCHES>
  (
    LOOKAHEAD(Expression())
    ( jjtThis.rightExpression = Expression() )
    |
    ( jjtThis.right = PString() )
    |
    ( token = <CHARACTER_LITERAL> {jjtThis.right = token.image;} )
    |
    ( jjtThis.rightParam = InputParameter() )
  )
  {return jjtThis;}
}

OrderBy OrderBy():
{
  jjtThis.items = new java.util.ArrayList();
  OrderByItem lastItem;
  Identifier lastIdentifier;
  Modifier lastModifier;
  Token lastToken;
}
{
(
  <ORDER_BY>
  (
    (
      {
        lastItem = new OrderByItem();
        jjtThis.items.add(lastItem);
      }
      (
        (
          lastIdentifier = Identifier() { lastItem.alias = lastIdentifier.getStringValue(); }
          [ lastModifier = Modifier()  { lastItem.modifier = lastModifier; } ]
        )
        |
        lastToken = <RECORD_ATTRIBUTE> { lastItem.recordAttr = lastToken.image; }
      )
      [ <DESC> { lastItem.type = OrderByItem.DESC; }| <ASC>  { lastItem.type = OrderByItem.ASC; }]
    )
    |
    (
      <LPAREN>
      {
        lastItem = new OrderByItem();
        jjtThis.items.add(lastItem);
      }
      (
        (
          lastIdentifier = Identifier() { lastItem.alias = lastIdentifier.getStringValue(); }
          [ lastModifier = Modifier()  { lastItem.modifier = lastModifier; } ]
        )
        |
        lastToken = <RECORD_ATTRIBUTE> { lastItem.recordAttr = lastToken.image; }
      )
      [ <DESC> { lastItem.type = OrderByItem.DESC; }| <ASC>  { lastItem.type = OrderByItem.ASC; }]
      <RPAREN>
    )
  )
  (
    ","
    (
      (
        {
          lastItem = new OrderByItem();
          jjtThis.items.add(lastItem);
        }
        (
          (
            lastIdentifier = Identifier() { lastItem.alias = lastIdentifier.toString(); }
            [ lastModifier = Modifier()  { lastItem.modifier = lastModifier; } ]
          )
          |
          lastToken = <RECORD_ATTRIBUTE> { lastItem.recordAttr = lastToken.image; }
        )
        [ <DESC> { lastItem.type = OrderByItem.DESC; }| <ASC>  { lastItem.type = OrderByItem.ASC; }]
      )
      |
      (
        <LPAREN>
        {
          lastItem = new OrderByItem();
          jjtThis.items.add(lastItem);
        }
        (
          (
            lastIdentifier = Identifier() { lastItem.alias = lastIdentifier.toString(); }
            [ lastModifier = Modifier()  { lastItem.modifier = lastModifier; } ]
          )
          |
          lastToken = <RECORD_ATTRIBUTE> { lastItem.recordAttr = lastToken.image; }
        )
        [ <DESC> { lastItem.type = OrderByItem.DESC; }| <ASC>  { lastItem.type = OrderByItem.ASC; }]
        <RPAREN>
      )
    )
  )*
) {return jjtThis;}
}

GroupBy GroupBy():
{ Expression lastExpression; }
{
  <GROUP_BY> lastExpression = Expression() { jjtThis.items.add(lastExpression); }
  (
    ","
    lastExpression = Expression() { jjtThis.items.add(lastExpression); }
  )*
  {return jjtThis;}
}

Unwind Unwind():
{ Identifier lastIdentifier; }
{
  <UNWIND> lastIdentifier = Identifier() { jjtThis.items.add(lastIdentifier); }
  (
    ","
    lastIdentifier = Identifier() { jjtThis.items.add(lastIdentifier); }
  )*
  {return jjtThis;}
}

Limit Limit():
{}
{
  <LIMIT>
  (
    jjtThis.num  = PInteger()
    |
    jjtThis.inputParam = InputParameter()
  )
  { return jjtThis; }
}

Skip Skip():
{ }
{
  (
    (
      <SKIP2>
      (
        jjtThis.num  = PInteger()
        |
        jjtThis.inputParam = InputParameter()
      )
    )
    |
    (
      <OFFSET>
      (
        jjtThis.num  = PInteger()
        |
        jjtThis.inputParam = InputParameter()
      )
    )
  ) {return jjtThis;}
}

Batch Batch():
{}
{
    (
    	<BATCH>
    	(
            jjtThis.num  = PInteger()
            |
            jjtThis.inputParam = InputParameter()
        )
    )
    { return jjtThis; }
}

Timeout Timeout():
{ PInteger val; }
{
  <TIMEOUT>
  val = PInteger() { jjtThis.val = val.getValue(); }
  [
    ( <RETURN> { jjtThis.failureStrategy = Timeout.RETURN;} )
    |
    ( <EXCEPTION> { jjtThis.failureStrategy = Timeout.EXCEPTION;} )
  ]
  { return jjtThis; }
}

java.lang.Number Wait():
{ PInteger val; }
{
  <WAIT> val = PInteger()
  { return val.getValue(); }
}

java.lang.Number Retry():
{ PInteger val; }
{
  <RETRY> val = PInteger()
  { return val.getValue(); }
}

PCollection PCollection():
{
  Expression lastExpression;
}
{
  (
    <LBRACKET>
    [
      lastExpression = Expression() { jjtThis.expressions.add(lastExpression); }
      (
        <COMMA>
        lastExpression = Expression() { jjtThis.expressions.add(lastExpression); }
      )*
    ]
    <RBRACKET>
  )
  { return jjtThis; }
}

TraverseProjectionItem TraverseProjectionItem():
{}
{
  (
    jjtThis.base = BaseIdentifier()
    [ LOOKAHEAD( Modifier() ) jjtThis.modifier = Modifier() ]
  )
  { return jjtThis; }
}

Json Json():
{
  JsonItem lastItem;
  Token token;
}
{
  (
    <LBRACE>
    [
      { lastItem = new JsonItem(); }
      (
        lastItem.leftIdentifier = Identifier()
        |
        token = <RECORD_ATTRIBUTE> {lastItem.leftString = token.image; }
        |
        ( lastItem.leftString = PString() { lastItem.leftString = lastItem.leftString.substring(1, lastItem.leftString.length() - 1); } )
        |
        token = <CHARACTER_LITERAL> { lastItem.leftString = token.image.substring(1, token.image.length() - 1); }
      )
      <COLON>
      lastItem.right = Expression() { jjtThis.items.add(lastItem); }
      (
        <COMMA>
        { lastItem = new JsonItem(); }
        (
          lastItem.leftIdentifier = Identifier()
          |
          token = <RECORD_ATTRIBUTE> {lastItem.leftString = token.image; }
          |
          ( lastItem.leftString = PString() { lastItem.leftString = lastItem.leftString.substring(1, lastItem.leftString.length() - 1); } )
          |
          token = <CHARACTER_LITERAL> { lastItem.leftString = token.image.substring(1, token.image.length() - 1); }
        )
        <COLON>
        lastItem.right = Expression() { jjtThis.items.add(lastItem); }
      )*
    ]
    <RBRACE>
  )
  {return jjtThis;}
}


JsonArray JsonArray():
{
  Json lastItem;
  Token token;
}
{
  (
    <LBRACKET>
    [
      lastItem = Json()
      {
        jjtThis.items = new ArrayList();
        jjtThis.items.add(lastItem);
      }
      (
        <COMMA>
        lastItem = Json() { jjtThis.items.add(lastItem); }
      )*
    ]
    <RBRACKET>
  )
  {return jjtThis;}
}

MatchExpression MatchExpression():
{ MatchPathItem nextItem = null; }
{
  (
    jjtThis.origin = MatchFilter()
    (
      (
        LOOKAHEAD(3)
        nextItem = MatchPathItem()
        |
        LOOKAHEAD(3)
        nextItem = MultiMatchPathItemArrows()
        |
        LOOKAHEAD(3)
        nextItem = MultiMatchPathItem()
        |
        LOOKAHEAD(OutPathItem())
        nextItem = OutPathItem()
        |
        nextItem = InPathItem()
        |
        LOOKAHEAD(BothPathItem())
        nextItem = BothPathItem()
        |
        nextItem = FieldMatchPathItem()
      )
      { jjtThis.items.add(nextItem); }
    )*
  ) { return jjtThis; }
}


MatchPathItem MatchPathItem():
{}
{
  (
    jjtThis.method = MethodCall()
    [ jjtThis.filter = MatchFilter() ]
  ){ return jjtThis; }
}

MatchPathItem FieldMatchPathItem():
{}
{
  (
    <DOT>
    jjtThis.field = Identifier()
    [ jjtThis.filter = MatchFilter() ]
  ){ return jjtThis; }
}

MatchPathItem MatchPathItemFirst():
{}
{
  (
    jjtThis.function = FunctionCall()
    [ jjtThis.filter = MatchFilter() ]
  ){ return jjtThis; }
}

MatchPathItem MultiMatchPathItem():
{ MatchPathItem nextItem = null; }
{
  (
    <DOT>
    <LPAREN>
    (
      nextItem = MatchPathItemFirst() { jjtThis.items.add(nextItem); }
    )
    (
      LOOKAHEAD(MatchPathItem())
      nextItem = MatchPathItem() { jjtThis.items.add(nextItem); }
    )*
    <RPAREN>
    [ jjtThis.filter = MatchFilter() ]
  ){ return jjtThis; }
}

MatchPathItem MultiMatchPathItemArrows():
{
  MatchPathItem item = null;
}
{
  <DOT>
  <LPAREN>
  (
    (
      LOOKAHEAD( OutPathItemOpt() )
      item = OutPathItemOpt()  { jjtThis.items.add(item); }
      |
      LOOKAHEAD( InPathItemOpt() )
      item = InPathItemOpt()  { jjtThis.items.add(item); }
      |
      LOOKAHEAD( BothPathItemOpt() )
      item = BothPathItemOpt()  { jjtThis.items.add(item); }
    )
  )+
  <RPAREN>
  [ jjtThis.filter = MatchFilter() ]
  { return jjtThis; }
}

MatchFilter MatchFilter():
{ MatchFilterItem lastItem = null; }
{
  <LBRACE>
    [
      lastItem = MatchFilterItem() { jjtThis.items.add(lastItem); }
      (
        <COMMA>
        lastItem = MatchFilterItem() { jjtThis.items.add(lastItem); }
      )*
    ]
  <RBRACE>
  { return jjtThis; }
}

MatchFilterItem MatchFilterItem():
{Token lastToken;}
{
  (
    (
      <TYPE> <COLON> jjtThis.typeName = Expression()
    )
    |
    (
      <TYPES> <COLON> jjtThis.typeNames = Expression()
    )
    |
    (
      <BUCKET> <COLON>
      (
         jjtThis.bucketName = Identifier()
         |
         jjtThis.bucketId = PInteger()
      )
    )
    |
    (
      (
        lastToken = <BUCKET_IDENTIFIER> {jjtThis.bucketName = new Identifier(lastToken.image.split(":")[1]);}
        |
        lastToken = <BUCKET_NUMBER_IDENTIFIER> {jjtThis.bucketId = new PInteger(-1); jjtThis.bucketId.setValue(Integer.parseInt(lastToken.image.split(":")[1]));}
      )
    )
    |
    (
      <RID> <COLON> jjtThis.rid = Rid()
    )
    |
    (
      <AS> <COLON> jjtThis.alias = Identifier()
    )
    |
    (
      <WHERE> <COLON> <LPAREN>
      (
        jjtThis.filter = WhereClause()
      )
      <RPAREN>
    )
    |
    (
      <WHILE> <COLON> <LPAREN>
      (
        jjtThis.whileCondition = WhereClause()
      )
      <RPAREN>
    )
    |
    (
      <MAXDEPTH> <COLON> jjtThis.maxDepth = PInteger()
    )
    |
    (
      <OPTIONAL> <COLON>
      (
        <TRUE> { jjtThis.optional = true; }
        |
        <FALSE> { jjtThis.optional = false; }
      )
    )
    |
    (
        <DEPTH_ALIAS> <COLON> jjtThis.depthAlias = Identifier()
    )
    |
    (
        <PATH_ALIAS> <COLON> jjtThis.pathAlias = Identifier()
    )
  )
  { return jjtThis; }
}

MatchPathItem OutPathItem():
{ Identifier edgeName = null; }
{
    (
      (
        <MINUS>
        [edgeName = Identifier()]
        <MINUS>
      )
      |
      <DECR>
    )
    <GT>
    jjtThis.filter = MatchFilter()

  {
   jjtThis.method = new MethodCall(-1);
   jjtThis.method.methodName = new Identifier("out");
   if (edgeName != null) {
     Expression exp = new Expression(-1);
     BaseExpression sub = new BaseExpression(edgeName.getStringValue());
     exp.mathExpression = sub;
     jjtThis.method.params.add(exp);
   }
   return jjtThis;
  }
}

MatchPathItem InPathItem():
{ Identifier edgeName = null; }
{
    <LT>
    (
      (
        <MINUS>
        [edgeName = Identifier()]
        <MINUS>
      )
      |
      <DECR>
    )
    jjtThis.filter = MatchFilter()

  {
   jjtThis.method = new MethodCall(-1);
   jjtThis.method.methodName = new Identifier("in");
   if (edgeName != null) {
     Expression exp = new Expression(-1);
     BaseExpression sub = new BaseExpression(edgeName.getStringValue());
     exp.mathExpression = sub;
     jjtThis.method.params.add(exp);
   }
   return jjtThis;
  }
}

MatchPathItem BothPathItem():
{ Identifier edgeName = null; }
{
    (
      (
        <MINUS>
        [edgeName = Identifier()]
        <MINUS>
      )
      |
      <DECR>
    )
    jjtThis.filter = MatchFilter()

  {
   jjtThis.method = new MethodCall(-1);
   jjtThis.method.methodName = new Identifier("both");
   if (edgeName != null) {
     Expression exp = new Expression(-1);
     BaseExpression sub = new BaseExpression(edgeName.getStringValue());
     exp.mathExpression = sub;
     jjtThis.method.params.add(exp);
   }
   return jjtThis;
  }
}


MatchPathItem OutPathItemOpt():
{ Identifier edgeName = null; }
{
    (
      (
        <MINUS>
        [edgeName = Identifier()]
        <MINUS>
      )
      |
      <DECR>
    )
    <GT>
    [jjtThis.filter = MatchFilter()]

  {
   jjtThis.method = new MethodCall(-1);
   jjtThis.method.methodName = new Identifier("out");
   if (edgeName != null) {
     Expression exp = new Expression(-1);
     BaseExpression sub = new BaseExpression(edgeName.getStringValue());
     exp.mathExpression = sub;
     jjtThis.method.params.add(exp);
   }
   return jjtThis;
  }
}

MatchPathItem InPathItemOpt():
{ Identifier edgeName = null; }
{
    <LT>
    (
      (
        <MINUS>
        [edgeName = Identifier()]
        <MINUS>
      )
      |
      <DECR>
    )
    [jjtThis.filter = MatchFilter()]

  {
   jjtThis.method = new MethodCall(-1);
   jjtThis.method.methodName = new Identifier("in");
   if(edgeName!=null){
     Expression exp = new Expression(-1);
     BaseExpression sub = new BaseExpression(edgeName.getStringValue());
     exp.mathExpression = sub;
     jjtThis.method.params.add(exp);
   }
   return jjtThis;
  }
}

MatchPathItem BothPathItemOpt():
{ Identifier edgeName = null; }
{
    (
      (
        <MINUS>
        [edgeName = Identifier()]
        <MINUS>
      )
      |
      <DECR>
    )
    [jjtThis.filter = MatchFilter()]

  {
   jjtThis.method = new MethodCall(-1);
   jjtThis.method.methodName = new Identifier("both");
   if (edgeName != null) {
     Expression exp = new Expression(-1);
     BaseExpression sub = new BaseExpression(edgeName.getStringValue());
     exp.mathExpression = sub;
     jjtThis.method.params.add(exp);
   }
   return jjtThis;
  }
}

TruncateTypeStatement TruncateTypeStatement():
{}
{
  <TRUNCATE> <TYPE>
  jjtThis.typeName = Identifier()
  [ <POLYMORPHIC> {jjtThis.polymorphic = true;} ]
  [ <UNSAFE> {jjtThis.unsafe = true;} ]
  { return jjtThis; }
}

TruncateBucketStatement TruncateBucketStatement():
{}
{
  <TRUNCATE> <BUCKET>
  (
    jjtThis.bucketName = Identifier()
    |
    jjtThis.bucketNumber = PInteger()
  )
  [ <UNSAFE> {jjtThis.unsafe = true;} ]
  { return jjtThis; }
}

TruncateRecordStatement TruncateRecordStatement():
{ Rid lastRecord; }
{
  <TRUNCATE> <RECORD>
  (
    jjtThis.record = Rid()
    |
    (
      <LBRACKET> { jjtThis.records = new ArrayList<Rid>(); }
      [
        lastRecord = Rid() { jjtThis.records.add(lastRecord); }
        (
          <COMMA>
          lastRecord = Rid() { jjtThis.records.add(lastRecord); }
        )*
      ]
      <RBRACKET>
    )
  )
  { return jjtThis; }
}

CreateDocumentTypeStatement CreateDocumentTypeStatement():
{
  Identifier lastIdentifier;
  BucketIdentifier lastBucket;
}
{
  <CREATE> <DOCUMENT> <TYPE>
  jjtThis.name = Identifier()
  [ <IF> <NOT> <EXISTS> { jjtThis.ifNotExists = true; } ]
  [
    <EXTENDS> lastIdentifier = Identifier() { jjtThis.supertypes = new ArrayList<Identifier>(); jjtThis.supertypes.add(lastIdentifier); }
     (
      <COMMA>
      lastIdentifier = Identifier() { jjtThis.supertypes.add(lastIdentifier); }
     )*
  ]
  [
    <BUCKET> lastBucket = BucketIdentifier() { jjtThis.buckets = new ArrayList<BucketIdentifier>(); jjtThis.buckets.add(lastBucket); }
    (
      <COMMA>
      lastBucket = BucketIdentifier() { jjtThis.buckets.add(lastBucket); }
    )*
  ]
  [ <BUCKETS> jjtThis.totalBucketNo = PInteger() ]
  { return jjtThis; }
}

CreateVertexTypeStatement CreateVertexTypeStatement():
{
  Identifier lastIdentifier;
  BucketIdentifier lastBucket;
}
{
  <CREATE> <VERTEX> <TYPE>
  jjtThis.name = Identifier()
  [ <IF> <NOT> <EXISTS> { jjtThis.ifNotExists = true; } ]
  [
    <EXTENDS> lastIdentifier = Identifier() { jjtThis.supertypes = new ArrayList<Identifier>(); jjtThis.supertypes.add(lastIdentifier); }
     (
      <COMMA>
      lastIdentifier = Identifier() { jjtThis.supertypes.add(lastIdentifier); }
     )*
  ]
  [
    <BUCKET> lastBucket = BucketIdentifier() { jjtThis.buckets = new ArrayList<BucketIdentifier>(); jjtThis.buckets.add(lastBucket); }
    (
      <COMMA>
      lastBucket = BucketIdentifier() { jjtThis.buckets.add(lastBucket); }
    )*
  ]
  [ <BUCKETS> jjtThis.totalBucketNo = PInteger() ]
  { return jjtThis; }
}

CreateEdgeTypeStatement CreateEdgeTypeStatement():
{
  Identifier lastIdentifier;
  BucketIdentifier lastBucket;
}
{
  <CREATE> <EDGE> <TYPE>
  jjtThis.name = Identifier()
  [ <IF> <NOT> <EXISTS> { jjtThis.ifNotExists = true; } ]
  [
    <EXTENDS> lastIdentifier = Identifier() { jjtThis.supertypes = new ArrayList<Identifier>(); jjtThis.supertypes.add(lastIdentifier); }
     (
      <COMMA>
      lastIdentifier = Identifier() { jjtThis.supertypes.add(lastIdentifier); }
     )*
  ]
  [
    <BUCKET> lastBucket = BucketIdentifier() { jjtThis.buckets = new ArrayList<BucketIdentifier>(); jjtThis.buckets.add(lastBucket); }
    (
      <COMMA>
      lastBucket = BucketIdentifier() { jjtThis.buckets.add(lastBucket); }
    )*
  ]
  [ <BUCKETS> jjtThis.totalBucketNo = PInteger() ]
  [ <UNIDIRECTIONAL> { jjtThis.unidirectional = true; }]
  { return jjtThis; }
}

AlterTypeStatement AlterTypeStatement():
{
  Identifier lastIdentifier;
  PInteger lastInteger;
  Token lastToken;
}
{
  <ALTER> <TYPE>
  jjtThis.name = Identifier()
  (
    (
      <NAME> { jjtThis.property = "name"; }
      jjtThis.identifierValue = Identifier()
    )
    |
    (
      <SUPERTYPE> {
        jjtThis.property = "supertype";
      }
      (
        (
          (
            (
              <PLUS> {jjtThis.identifierListAddRemove.add(true);}
            )
            |
            (
              <MINUS> {jjtThis.identifierListAddRemove.add(false);}
            )
          )
          lastIdentifier = Identifier() { jjtThis.identifierListValue.add(lastIdentifier); }
          (
            <COMMA>
            (
              (
                <PLUS> {jjtThis.identifierListAddRemove.add(true);}
              )
              |
              (
                <MINUS> {jjtThis.identifierListAddRemove.add(false);}
              )
            )
            lastIdentifier = Identifier() { jjtThis.identifierListValue.add(lastIdentifier); }
          )*
        )
        |
        <NULL> { jjtThis.identifierListValue = null; }
      )
    )
    |
    (
      <ALIASES> {
        jjtThis.property = "aliases";
      }
      (
        (
          lastIdentifier = Identifier() { jjtThis.identifierListValue.add(lastIdentifier); }
          (
            <COMMA>
            lastIdentifier = Identifier() { jjtThis.identifierListValue.add(lastIdentifier); }
          )*
        )
        |
        <NULL> { jjtThis.identifierListValue = null; }
      )
    )
    |
    (
      <BUCKET> { jjtThis.property = "bucket"; }
      (
        (
          <PLUS> {jjtThis.identifierListAddRemove.add(true);}
        )
        |
        (
          <MINUS> {jjtThis.identifierListAddRemove.add(false);}
        )
      )
      lastIdentifier = Identifier() { jjtThis.identifierListValue.add(lastIdentifier); }
      (
        <COMMA>
        (
          (
            <PLUS> {jjtThis.identifierListAddRemove.add(true);}
          )
          |
          (
            <MINUS> {jjtThis.identifierListAddRemove.add(false);}
          )
        )
        lastIdentifier = Identifier() { jjtThis.identifierListValue.add(lastIdentifier); }
      )*
    )
    |
    <BUCKETSELECTIONSTRATEGY> { jjtThis.property = "bucketSelectionStrategy"; } jjtThis.identifierValue = Identifier()
    |
    (
      <CUSTOM>
      jjtThis.customKey = Identifier()
      <EQ>
      jjtThis.customValue = Expression()
    )
  )
  { return jjtThis; }
}

DropTypeStatement DropTypeStatement():
{}
{
  <DROP> <TYPE>
  (
  jjtThis.name = Identifier()
  |
  jjtThis.nameParam = InputParameter()
  )
  [ <IF> <EXISTS> { jjtThis.ifExists = true; } ]
  [ <UNSAFE> { jjtThis.unsafe = true; } ]
  { return jjtThis; }
}

CreatePropertyStatement CreatePropertyStatement():
{
  CreatePropertyAttributeStatement lastAttribute;
}
{
  <CREATE> <PROPERTY>
  jjtThis.typeName = Identifier()
  <DOT>
  jjtThis.propertyName = Identifier()
  [ <IF> <NOT> <EXISTS> { jjtThis.ifNotExists = true; }]
  jjtThis.propertyType = Identifier()
  [ <OF> jjtThis.ofType = Identifier() ]
  [
    <LPAREN>
    lastAttribute = CreatePropertyAttributeStatement() { jjtThis.attributes.add(lastAttribute); }
    (<COMMA> lastAttribute = CreatePropertyAttributeStatement() { jjtThis.attributes.add(lastAttribute); })*
    <RPAREN>
  ]
  { return jjtThis; }
}

CreatePropertyAttributeStatement CreatePropertyAttributeStatement():
{
}
{
  (
    jjtThis.settingName = Identifier()
    [LOOKAHEAD( { getToken(1).kind != COMMA && getToken(1).kind != RPAREN} )
       jjtThis.settingValue = Expression()
    ]
  )

  { return jjtThis; }
}

AlterPropertyStatement AlterPropertyStatement():
{}
{
  <ALTER> <PROPERTY>
  jjtThis.typeName = Identifier()
  <DOT>
  jjtThis.propertyName = Identifier()
  (
    LOOKAHEAD(3)
    (
      <CUSTOM>
      jjtThis.customPropertyName = Identifier()
      <EQ>
      jjtThis.customPropertyValue = Expression()
    )
    |
    (
      jjtThis.settingName = Identifier()
      jjtThis.settingValue = Expression()
    )
  )
  { return jjtThis; }
}

DropPropertyStatement DropPropertyStatement():
{}
{
  <DROP> <PROPERTY>
  jjtThis.typeName = Identifier()
  <DOT>
  jjtThis.propertyName = Identifier()
  [ <IF> <EXISTS> { jjtThis.ifExists = true; } ]
  [ <FORCE> { jjtThis.force = true; }]
  { return jjtThis; }
}

CreateIndexStatement CreateIndexStatement():
{
  CreateIndexStatement.Property lastProperty;
  Identifier lastIdentifier;
  RecordAttribute lastRecordAttr;
}
{
  <CREATE> <INDEX>
  (
    (
      LOOKAHEAD(6)
      (
        [<IF> <NOT> <EXISTS> {jjtThis.ifNotExists = true;}]
        <ON>
        jjtThis.typeName = Identifier()
        <LPAREN>
        (
          lastIdentifier = Identifier() {
            lastProperty = new CreateIndexStatement.Property();
            lastProperty.name = lastIdentifier;
            jjtThis.propertyList.add(lastProperty);
          }
          |
          lastRecordAttr = RecordAttribute() {
            lastProperty = new CreateIndexStatement.Property();
            lastProperty.recordAttribute = lastRecordAttr;
            jjtThis.propertyList.add(lastProperty);
          }
        )
        [
          <BY>
          (
            <KEY> { lastProperty.byKey = true; }
            |
            <VALUE> { lastProperty.byValue = true; }
            |
            <ITEM> { lastProperty.byItem = true; }
          )
        ]
        (
          <COMMA>
          (
            lastIdentifier = Identifier() {
              lastProperty = new CreateIndexStatement.Property();
              lastProperty.name = lastIdentifier;
              jjtThis.propertyList.add(lastProperty);
            }
            |
            lastRecordAttr = RecordAttribute() {
              lastProperty = new CreateIndexStatement.Property();
              lastProperty.recordAttribute = lastRecordAttr;
              jjtThis.propertyList.add(lastProperty);
            }
          )
          [
            <BY>
            (
              <KEY> { lastProperty.byKey = true; }
              |
              <VALUE> { lastProperty.byValue = true; }
              |
              <ITEM> { lastProperty.byItem = true; }
            )
          ]
        )*
        <RPAREN>
      )
      |
      (
        jjtThis.name = Identifier()
      )
    )
    (
        LOOKAHEAD(4)
        (
            <IF> <NOT> <EXISTS> {jjtThis.ifNotExists = true;}
            jjtThis.type = Identifier()
        )
        |
        jjtThis.type = Identifier()
    )
    (
      LOOKAHEAD(2)
      <ENGINE> jjtThis.engine = Identifier()
      [
        LOOKAHEAD(2)
        (
           <METADATA> jjtThis.metadata = Json()
        )
        |
        (
          lastIdentifier = Identifier() {jjtThis.keyTypes.add(lastIdentifier);}
          (
            <COMMA> lastIdentifier = Identifier() {jjtThis.keyTypes.add(lastIdentifier);}
          )*
          [ <METADATA> jjtThis.metadata = Json() ]
        )
      ]
      |
      [
        LOOKAHEAD(2)
        (
           <METADATA> jjtThis.metadata = Json()
        )
        |
        (
          lastIdentifier = Identifier() {jjtThis.keyTypes.add(lastIdentifier);}
          (
            <COMMA> lastIdentifier = Identifier() {jjtThis.keyTypes.add(lastIdentifier);}
          )*
          [ <METADATA> jjtThis.metadata = Json() ]
        )
      ]
    )

    [ <NULL_STRATEGY>
      (
        <SKIP2> { jjtThis.nullStrategy = LSMTreeIndexAbstract.NULL_STRATEGY.SKIP; }
        |
        <ERROR2> { jjtThis.nullStrategy = LSMTreeIndexAbstract.NULL_STRATEGY.ERROR; }
      )
    ]
  )
  { return jjtThis; }
}

RebuildIndexStatement RebuildIndexStatement():
{}
{
  <REBUILD> <INDEX>
  (
    (
      jjtThis.name = Identifier()
      |
      <STAR> { jjtThis.all = true; }
    )
    [
      <WITH>
      jjtThis.key = Expression() <EQ> jjtThis.value = Expression() { jjtThis.settings.put( jjtThis.key, jjtThis.value ); }
      (
        <COMMA>
        jjtThis.key = Expression() <EQ> jjtThis.value = Expression() { jjtThis.settings.put( jjtThis.key, jjtThis.value ); }
      )*
    ]
  )
  [
    <WITH>
    jjtThis.key = Expression() <EQ> jjtThis.value = Expression() { jjtThis.settings.put( jjtThis.key, jjtThis.value ); }
    (
      <COMMA>
      jjtThis.key = Expression() <EQ> jjtThis.value = Expression() { jjtThis.settings.put( jjtThis.key, jjtThis.value ); }
    )*
  ]
  { return jjtThis; }
}

DropIndexStatement DropIndexStatement():
{}
{
  <DROP> <INDEX>
  (
    jjtThis.name = Identifier()
    |
    <STAR> { jjtThis.all = true; }
  )
  [ <IF> <EXISTS> { jjtThis.ifExists = true; }]
  { return jjtThis; }
}


CreateBucketStatement CreateBucketStatement():
{}
{
  <CREATE> <BUCKET>
  jjtThis.name = Identifier()
  [ <IF> <NOT> <EXISTS> { jjtThis.ifNotExists = true; } ]
  { return jjtThis; }
}

AlterBucketStatement AlterBucketStatement():
{}
{
  <ALTER> <BUCKET>
  (
    jjtThis.name = Identifier()
  )
  [ <STAR> { jjtThis.starred = true; }]
  jjtThis.attributeName = Identifier()
  jjtThis.attributeValue = Expression()
  { return jjtThis; }
}

DropBucketStatement DropBucketStatement():
{}
{
  <DROP> <BUCKET>
  (
    jjtThis.name = Identifier()
    |
    jjtThis.id = PInteger()
  )
  [ <IF> <EXISTS> { jjtThis.ifExists = true; } ]
  { return jjtThis; }
}

AlterDatabaseStatement AlterDatabaseStatement():
{}
{
  <ALTER> <DATABASE>
  jjtThis.settingName = Identifier()
  jjtThis.settingValue = Expression()
  { return jjtThis; }
}

ExplainStatement ExplainStatement():
{}
{
  <EXPLAIN>
  jjtThis.statement = StatementInternal()
  { return jjtThis; }
}

ProfileStatement ProfileStatement():
{}
{
  <PROFILE>
  jjtThis.statement = StatementInternal()
  { return jjtThis; }
}

LetStatement LetStatement():
{ }
{
  <LET>
  jjtThis.variableName = Identifier()
  <EQ>
  (
    LOOKAHEAD(Statement())
    jjtThis.statement =  StatementInternal()
    |
    LOOKAHEAD(Expression())
    jjtThis.expression = Expression()
  )
  {return jjtThis;}
}

BeginStatement BeginStatement():
{}
{
  <BEGIN>
  [ <ISOLATION> jjtThis.isolation = Identifier() ]
  {return jjtThis;}
}

CommitStatement CommitStatement():
{ Statement last;}
{
  <COMMIT>
  [
    <RETRY> jjtThis.retry = PInteger()
    [
      <ELSE>
      (
        (
          { jjtThis.elseStatements = new ArrayList(); }
          <LBRACE>
          (
            last = StatementInternal() { jjtThis.addElse(last); }
            <SEMICOLON>
          )+
          <RBRACE>
          [
            <AND> ( ( <CONTINUE> { jjtThis.elseFail = false; } ) | ( <FAIL> { jjtThis.elseFail = true; } ) )
          ]
        )
        |
        ( <CONTINUE> { jjtThis.elseFail = false; } ) | ( <FAIL> { jjtThis.elseFail = true; } )
      )
    ]
  ]
  {return jjtThis;}
}

RollbackStatement RollbackStatement():
{ }
{
  <ROLLBACK>
  {return jjtThis;}
}

LockStatement LockStatement():
{
  jjtThis.identifiers = new java.util.ArrayList();
  Identifier lastLockIdentifier;
}
{
  <LOCK>
  (
    ( <TYPE> { jjtThis.mode = "TYPE"; } )
    |
    ( <BUCKET> { jjtThis.mode = "BUCKET"; } )
  )

  lastLockIdentifier = Identifier() { jjtThis.identifiers.add(lastLockIdentifier); }
  ( <COMMA> lastLockIdentifier = Identifier() { jjtThis.identifiers.add(lastLockIdentifier); } )*
  { return jjtThis; }
}

BreakStatement BreakStatement():
{ }
{
  <BREAK>
  {return jjtThis;}
}

ReturnStatement ReturnStatement():
{ }
{
  <RETURN>
  [
    jjtThis.expression = Expression()
  ]
  {return jjtThis;}
}

IfStatement IfStatement():
{ Statement last; }
{
  <IF><LPAREN>
  jjtThis.expression = OrBlock()
  <RPAREN><LBRACE>
  (
    LOOKAHEAD(StatementSemicolon())
    last = StatementSemicolon() { jjtThis.statements.add(last); }
    |
    last = IfStatement() { jjtThis.statements.add(last); }
    |
    last = WhileBlock() {jjtThis.statements.add(last); }
    |
    last = ForEachBlock() {jjtThis.statements.add(last); }
    |
    last = BreakStatement() {jjtThis.statements.add(last); }
    |
    <SEMICOLON>
  )*
  <RBRACE>
  { return jjtThis; }
}

SleepStatement SleepStatement():
{ }
{
  <SLEEP> jjtThis.expression = Expression()
  { return jjtThis; }
}

ConsoleStatement ConsoleStatement():
{ }
{
  (
    <CONSOLE> <DOT>
    jjtThis.logLevel = Identifier()
    jjtThis.message = Expression()
  )
  { return jjtThis; }
}

ForEachBlock ForEachBlock():
{
  Statement last;
}
{
  <FOREACH> <LPAREN>
  jjtThis.loopVariable = Identifier()
  <IN>
  jjtThis.loopValues = Expression()
  <RPAREN>
  <LBRACE>
  (
    LOOKAHEAD(StatementSemicolon())
    last = StatementSemicolon() {jjtThis.statements.add(last); }
    |
    last = IfStatement() {jjtThis.statements.add(last); }
    |
    last = ForEachBlock() {jjtThis.statements.add(last); }
    |
    last = WhileBlock() {jjtThis.statements.add(last); }
    |
    last = BreakStatement() {jjtThis.statements.add(last); }
    |
    <SEMICOLON>
  )*
  <RBRACE>
  { return jjtThis; }
}

WhileBlock WhileBlock():
{
  Statement last;
}
{
  <WHILE> <LPAREN>
  jjtThis.condition = OrBlock()
  <RPAREN>
  <LBRACE>
  (
    LOOKAHEAD(StatementSemicolon())
    last = StatementSemicolon() {jjtThis.statements.add(last); }
    |
    last = IfStatement() {jjtThis.statements.add(last); }
    |
    last = ForEachBlock() {jjtThis.statements.add(last); }
    |
    last = WhileBlock() {jjtThis.statements.add(last); }
    |
    last = BreakStatement() {jjtThis.statements.add(last); }
    |
    <SEMICOLON>
  )*
  <RBRACE>
  { return jjtThis; }

}

ImportDatabaseStatement ImportDatabaseStatement():
{ }
{
  <IMPORT> <DATABASE>
  [ jjtThis.url = Url() ]
  [
    <WITH>
    jjtThis.key = Expression() <EQ> jjtThis.value = Expression() { jjtThis.settings.put( jjtThis.key, jjtThis.value ); }
    (
      <COMMA>
      jjtThis.key = Expression() <EQ> jjtThis.value = Expression() { jjtThis.settings.put( jjtThis.key, jjtThis.value ); }
    )*
  ]
  {return jjtThis; }
}

ExportDatabaseStatement ExportDatabaseStatement():
{ }
{
  <EXPORT> <DATABASE>
  [ jjtThis.url = Url() ]
  [ <FORMAT> jjtThis.format = Identifier() ]
  [ <OVERWRITE> ( <TRUE> { jjtThis.overwrite = BooleanExpression.TRUE;} | <FALSE> { jjtThis.overwrite = BooleanExpression.FALSE;} ) ]
  [
    <WITH>
    jjtThis.key = Expression() <EQ> jjtThis.value = Expression() { jjtThis.settings.put( jjtThis.key, jjtThis.value ); }
    (
      <COMMA>
      jjtThis.key = Expression() <EQ> jjtThis.value = Expression() { jjtThis.settings.put( jjtThis.key, jjtThis.value ); }
    )*
  ]
  {return jjtThis; }
}

Url Url():
{
 Token token;
}
{
  (
  token = <HTTP_URL> { jjtThis.urlString = token.image;}
  |
  token = <HTTPS_URL> { jjtThis.urlString = token.image;}
  |
  token = <FILE_URL> { jjtThis.urlString = token.image;}
  |
  token = <CLASSPATH_URL> { jjtThis.urlString = token.image;}
  )
  { return jjtThis; }
}

BackupDatabaseStatement BackupDatabaseStatement():
{ }
{
  <BACKUP> <DATABASE> [ jjtThis.url = Url() ]
  [
    <WITH>
    jjtThis.key = Expression() <EQ> jjtThis.value = Expression() { jjtThis.settings.put( jjtThis.key, jjtThis.value ); }
    (
      <COMMA>
      jjtThis.key = Expression() <EQ> jjtThis.value = Expression() { jjtThis.settings.put( jjtThis.key, jjtThis.value ); }
    )*
  ]
  {return jjtThis; }
}

CheckDatabaseStatement CheckDatabaseStatement():
{
  Identifier lastType;
  BucketIdentifier lastBucket;
}
{
  <CHECK> <DATABASE>
  [ <TYPE>
    lastType = Identifier() { jjtThis.types.add(lastType); }
    ( <COMMA> lastType = Identifier() { jjtThis.types.add(lastType); } )*
  ]
  [ <BUCKET> lastBucket = BucketIdentifier() { jjtThis.buckets.add(lastBucket); }
    (
      <COMMA>
      lastBucket = BucketIdentifier() { jjtThis.buckets.add(lastBucket); }
    )*
  ]
  [ <FIX> { jjtThis.fix = true; } ]
  [ <COMPRESS> { jjtThis.compress = true; } ]
  {return jjtThis; }
}

AlignDatabaseStatement AlignDatabaseStatement():
{
  BucketIdentifier lastBucket;
  String lastType;
}
{
  <ALIGN> <DATABASE>
  {return jjtThis; }
}

DefineFunctionStatement DefineFunctionStatement():
{
  Token token;
  Identifier lastIdentifier;
}
{
  <DEFINE> <FUNCTION>
  jjtThis.libraryName = Identifier()
  <DOT>
  jjtThis.functionName = Identifier()
  (
    jjtThis.codeQuoted = PString()
    { jjtThis.code = jjtThis.codeQuoted.substring(1, jjtThis.codeQuoted.length() -1); }
  )
  [
    <PARAMETERS>
    <LBRACKET>
    lastIdentifier = Identifier() {
      jjtThis.parameters = new ArrayList<Identifier>();
      jjtThis.parameters.add(lastIdentifier);
    }
    (
      <COMMA>
      lastIdentifier = Identifier() { jjtThis.parameters.add(lastIdentifier); }
    )*
    <RBRACKET>
  ]
  [
    <LANGUAGE>
    jjtThis.language = Identifier()
  ]
  { return jjtThis; }
}

DeleteFunctionStatement DeleteFunctionStatement():
{
  Token token;
  Identifier lastIdentifier;
}
{
  <DELETE> <FUNCTION>
  jjtThis.libraryName = Identifier()
  <DOT>
  jjtThis.functionName = Identifier()
  { return jjtThis; }
}
