/*
 * Copyright Â© 2021-present Arcade Data Ltd (info@arcadedata.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: 2021-present Arcade Data Ltd (info@arcadedata.com)
 * SPDX-License-Identifier: Apache-2.0
 */
/* GraphQLParser.java */
/* Generated by:  JJTree&ParserGeneratorCC: Do not edit this line. GraphQLParser.java */
package com.arcadedb.graphql.parser;

import java.io.StringReader;

public class GraphQLParser/*@bgen(jjtree)*/implements GraphQLParserTreeConstants, GraphQLParserConstants {/*@bgen(jjtree)*/
  protected JJTGraphQLParserState jjtree = new JJTGraphQLParserState();private int tokenId = 0;


    public static Document parse(String query) throws ParseException {
      return new GraphQLParser(new SimpleCharStream(new StringReader(query))).Document();
    }


    private int line() {
        return token_source.input_stream.getBeginLine();
    }

    private int column() {
        return token_source.input_stream.getBeginColumn();
    }

    private int tokenId() {
        return tokenId++;
    }

// Document structure
  final public Document Document() throws ParseException {/*@bgen(jjtree) Document */
    Document jjtn000 = new Document(JJTDOCUMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    Definition lastDef;
    try {
      label_1:
      while (true) {
        lastDef = Definition();
jjtn000.definitions.add(lastDef);
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case OCBR:
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:{
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Definition Definition() throws ParseException {/*@bgen(jjtree) Definition */
  Definition jjtn000 = new Definition(JJTDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));Definition def;
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case OCBR:
      case QUERY:
      case MUTATION:{
        def = OperationDefinition();
        break;
        }
      case FRAGMENT:{
        def = FragmentDefinition();
        break;
        }
      case SCHEMA:
      case SCALAR:
      case TYPE:
      case INTERFACE:
      case ENUM:
      case UNION:
      case INPUT:
      case EXTEND:
      case DIRECTIVE:{
        def = TypeSystemDefinition();
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return def;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public OperationDefinition OperationDefinition() throws ParseException {/*@bgen(jjtree) OperationDefinition */
    OperationDefinition jjtn000 = new OperationDefinition(JJTOPERATIONDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case OCBR:{
        jjtn000.selectionSet = SelectionSet();
        break;
        }
      case QUERY:
      case MUTATION:{
        jjtn000.operationType = OperationType();
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          jjtn000.name = Name();
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          ;
        }
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case OPAR:{
          jjtn000.variableDefinitions = VariableDefinitions();
          break;
          }
        default:
          jj_la1[3] = jj_gen;
          ;
        }
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case AT:{
          jjtn000.directives = Directives();
          break;
          }
        default:
          jj_la1[4] = jj_gen;
          ;
        }
        jjtn000.selectionSet = SelectionSet();
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public VariableDefinitions VariableDefinitions() throws ParseException {/*@bgen(jjtree) VariableDefinitions */
    VariableDefinitions jjtn000 = new VariableDefinitions(JJTVARIABLEDEFINITIONS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    VariableDefinition lastDef;
    try {
      jj_consume_token(OPAR);
      label_2:
      while (true) {
        lastDef = VariableDefinition();
jjtn000.variableDefinitions.add(lastDef);
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case DOLLAR:{
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          break label_2;
        }
      }
      jj_consume_token(CPAR);
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public VariableDefinition VariableDefinition() throws ParseException {/*@bgen(jjtree) VariableDefinition */
    VariableDefinition jjtn000 = new VariableDefinition(JJTVARIABLEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.variableLiteral = VariableLiteral();
      jj_consume_token(COLON);
      jjtn000.type = Type();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case EQ:{
        jjtn000.defaultValue = DefaultValue();
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public VariableLiteral VariableLiteral() throws ParseException {/*@bgen(jjtree) VariableLiteral */
    VariableLiteral jjtn000 = new VariableLiteral(JJTVARIABLELITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jj_consume_token(DOLLAR);
      jjtn000.name = Name();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public DefaultValue DefaultValue() throws ParseException {/*@bgen(jjtree) DefaultValue */
    DefaultValue jjtn000 = new DefaultValue(JJTDEFAULTVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jj_consume_token(EQ);
      jjtn000.value = Value();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

// Operations
  final public SelectionSet SelectionSet() throws ParseException {/*@bgen(jjtree) SelectionSet */
    SelectionSet jjtn000 = new SelectionSet(JJTSELECTIONSET);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();

    Selection lastSelection;
    try {
      jj_consume_token(OCBR);
      label_3:
      while (true) {
        lastSelection = Selection();
jjtn000.selections.add(lastSelection);
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case ELLIPSIS:
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[8] = jj_gen;
          break label_3;
        }
      }
      jj_consume_token(CCBR);
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Selection Selection() throws ParseException {/*@bgen(jjtree) Selection */
    Selection jjtn000 = new Selection(JJTSELECTION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case FRAGMENT:
      case QUERY:
      case MUTATION:
      case SCHEMA:
      case SCALAR:
      case TYPE:
      case INTERFACE:
      case IMPLEMENTS:
      case ENUM:
      case UNION:
      case INPUT:
      case EXTEND:
      case DIRECTIVE:
      case NAME_LITERAL:{
        jjtn000.name = Name();
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case COLON:{
          jjtn000.fieldWithAlias = FieldWithAlias(jjtn000.name, line, column, tokenId);
          break;
          }
        default:
          jj_la1[9] = jj_gen;
          jjtn000.field = Field(jjtn000.name, line, column, tokenId);
        }
        break;
        }
      case ELLIPSIS:{
        jj_consume_token(ELLIPSIS);
jjtn000.ellipsis = true;
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          jjtn000.fragmentSpread = FragmentSpread(line, column, tokenId);
          break;
          }
        case AT:
        case OCBR:
        case ON:{
          jjtn000.inlineFragment = InlineFragment(line, column, tokenId);
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Field Field(Name name, int line, int column, int tokenId) throws ParseException {/*@bgen(jjtree) Field */
  Field jjtn000 = new Field(JJTFIELD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case OPAR:{
        jjtn000.arguments = Arguments();
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case OCBR:{
        jjtn000.selectionSet = SelectionSet();
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public FieldWithAlias FieldWithAlias(Name alias, int line, int column, int tokenId) throws ParseException {/*@bgen(jjtree) FieldWithAlias */
  FieldWithAlias jjtn000 = new FieldWithAlias(JJTFIELDWITHALIAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(COLON);
      jjtn000.name = Name();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case OPAR:{
        jjtn000.arguments = Arguments();
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case OCBR:{
        jjtn000.selectionSet = SelectionSet();
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
       jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Arguments Arguments() throws ParseException {/*@bgen(jjtree) Arguments */
    Arguments jjtn000 = new Arguments(JJTARGUMENTS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    Argument lastArg;
    try {
      jj_consume_token(OPAR);
      lastArg = Argument();
jjtn000.arguments.add(lastArg);
      label_4:
      while (true) {
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case COMMA:{
          break;
          }
        default:
          jj_la1[18] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        lastArg = Argument();
jjtn000.arguments.add(lastArg);
      }
      jj_consume_token(CPAR);
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Argument Argument() throws ParseException {/*@bgen(jjtree) Argument */
    Argument jjtn000 = new Argument(JJTARGUMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.name = Name();
      jj_consume_token(COLON);
      jjtn000.valueWithVariable = ValueWithVariable();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

// Fragments
  final public FragmentSpread FragmentSpread(int line, int column, int tokenId) throws ParseException {/*@bgen(jjtree) FragmentSpread */
  FragmentSpread jjtn000 = new FragmentSpread(JJTFRAGMENTSPREAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jjtn000.name = FragmentName();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
       jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public InlineFragment InlineFragment(int line, int column, int tokenId) throws ParseException {/*@bgen(jjtree) InlineFragment */
  InlineFragment jjtn000 = new InlineFragment(JJTINLINEFRAGMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case ON:{
        jjtn000.typeCondition = TypeCondition();
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      jjtn000.selectionSet = SelectionSet();
jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
       jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public FragmentDefinition FragmentDefinition() throws ParseException {/*@bgen(jjtree) FragmentDefinition */
    FragmentDefinition jjtn000 = new FragmentDefinition(JJTFRAGMENTDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jj_consume_token(FRAGMENT);
      jjtn000.name = FragmentName();
      jjtn000.type = TypeCondition();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      jjtn000.selectionSet = SelectionSet();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public FragmentName FragmentName() throws ParseException {/*@bgen(jjtree) FragmentName */
  FragmentName jjtn000 = new FragmentName(JJTFRAGMENTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jjtn000.name = Name();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
// TODO if ("on".equals(name.image)) throw new ParseException("on is not allowed at a name");
        {if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public TypeCondition TypeCondition() throws ParseException {/*@bgen(jjtree) TypeCondition */
  TypeCondition jjtn000 = new TypeCondition(JJTTYPECONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jj_consume_token(ON);
      jjtn000.name = TypeName();
jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                                jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

// Values
  final public Name Name() throws ParseException {/*@bgen(jjtree) Name */
    Name jjtn000 = new Name(JJTNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));Token t;
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case NAME_LITERAL:{
        t = jj_consume_token(NAME_LITERAL);
        break;
        }
      case FRAGMENT:{
        t = jj_consume_token(FRAGMENT);
        break;
        }
      case QUERY:{
        t = jj_consume_token(QUERY);
        break;
        }
      case MUTATION:{
        t = jj_consume_token(MUTATION);
        break;
        }
      case SCHEMA:{
        t = jj_consume_token(SCHEMA);
        break;
        }
      case SCALAR:{
        t = jj_consume_token(SCALAR);
        break;
        }
      case TYPE:{
        t = jj_consume_token(TYPE);
        break;
        }
      case INTERFACE:{
        t = jj_consume_token(INTERFACE);
        break;
        }
      case IMPLEMENTS:{
        t = jj_consume_token(IMPLEMENTS);
        break;
        }
      case ENUM:{
        t = jj_consume_token(ENUM);
        break;
        }
      case UNION:{
        t = jj_consume_token(UNION);
        break;
        }
      case INPUT:{
        t = jj_consume_token(INPUT);
        break;
        }
      case EXTEND:{
        t = jj_consume_token(EXTEND);
        break;
        }
      case DIRECTIVE:{
        t = jj_consume_token(DIRECTIVE);
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
jjtn000.value = t.image;
        {if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Value Value() throws ParseException {/*@bgen(jjtree) Value */
  Value jjtn000 = new Value(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case INTEGER_LITERAL:{
        //TODO class hierarchy here instead?

                jjtn000.intValue = IntValue();
        break;
        }
      case FLOAT_LITERAL:{
        jjtn000.floatValue = FloatValue();
        break;
        }
      case STRING_LITERAL:{
        jjtn000.stringValue = StringValue();
        break;
        }
      case TRUE:
      case FALSE:{
        jjtn000.booleanValue = BooleanValue();
        break;
        }
      case FRAGMENT:
      case QUERY:
      case MUTATION:
      case SCHEMA:
      case SCALAR:
      case TYPE:
      case INTERFACE:
      case IMPLEMENTS:
      case ENUM:
      case UNION:
      case INPUT:
      case EXTEND:
      case DIRECTIVE:
      case NAME_LITERAL:{
        jjtn000.enumValue = EnumValue();
        break;
        }
      case OBRA:{
        jjtn000.listValue = ListValue();
        break;
        }
      case OCBR:{
        jjtn000.objectValue = ObjectValue();
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public ValueWithVariable ValueWithVariable() throws ParseException {/*@bgen(jjtree) ValueWithVariable */
  ValueWithVariable jjtn000 = new ValueWithVariable(JJTVALUEWITHVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case DOLLAR:{
        jjtn000.variableLiteral = VariableLiteral();
        break;
        }
      case INTEGER_LITERAL:{
        jjtn000.intValue = IntValue();
        break;
        }
      case FLOAT_LITERAL:{
        jjtn000.floatValue = FloatValue();
        break;
        }
      case STRING_LITERAL:{
        jjtn000.stringValue = StringValue();
        break;
        }
      case TRUE:
      case FALSE:{
        jjtn000.booleanValue = BooleanValue();
        break;
        }
      case FRAGMENT:
      case QUERY:
      case MUTATION:
      case SCHEMA:
      case SCALAR:
      case TYPE:
      case INTERFACE:
      case IMPLEMENTS:
      case ENUM:
      case UNION:
      case INPUT:
      case EXTEND:
      case DIRECTIVE:
      case NAME_LITERAL:{
        jjtn000.enumValue = EnumValue();
        break;
        }
      case OBRA:{
        jjtn000.listValueWithVariable = ListValueWithVariable();
        break;
        }
      case OCBR:{
        jjtn000.objectValueWithVariable = ObjectValueWithVariable();
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public EnumValue EnumValue() throws ParseException {/*@bgen(jjtree) EnumValue */
    EnumValue jjtn000 = new EnumValue(JJTENUMVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.name = Name();
jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.jjtSetLastToken(getToken(0));
//TODO if ("true".equals(name.image)
        //TODO      || "false".equals(name.image)
        //TODO      || "null".equals(name.image)) throw new ParseException("true, false, null are not allowed as names");

        {if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

// List Value
  final public ListValue ListValue() throws ParseException {/*@bgen(jjtree) ListValue */
    ListValue jjtn000 = new ListValue(JJTLISTVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();

    Value lastVal;
    try {
      jj_consume_token(OBRA);
      label_5:
      while (true) {
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case OBRA:
        case OCBR:
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case TRUE:
        case FALSE:
        case INTEGER_LITERAL:
        case FLOAT_LITERAL:
        case STRING_LITERAL:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[26] = jj_gen;
          break label_5;
        }
        lastVal = Value();
jjtn000.values.add(lastVal);
      }
      jj_consume_token(CBRA);
jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public ListValueWithVariable ListValueWithVariable() throws ParseException {/*@bgen(jjtree) ListValueWithVariable */
    ListValueWithVariable jjtn000 = new ListValueWithVariable(JJTLISTVALUEWITHVARIABLE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();

    ValueWithVariable lastVal;
    try {
      jj_consume_token(OBRA);
      label_6:
      while (true) {
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case DOLLAR:
        case OBRA:
        case OCBR:
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case TRUE:
        case FALSE:
        case INTEGER_LITERAL:
        case FLOAT_LITERAL:
        case STRING_LITERAL:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[27] = jj_gen;
          break label_6;
        }
        lastVal = ValueWithVariable();
jjtn000.values.add(lastVal);
      }
      jj_consume_token(CBRA);
jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

// Object Value
  final public ObjectValue ObjectValue() throws ParseException {/*@bgen(jjtree) ObjectValue */
    ObjectValue jjtn000 = new ObjectValue(JJTOBJECTVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();

    ObjectField lastVal;
    try {
      jj_consume_token(OCBR);
      label_7:
      while (true) {
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          break label_7;
        }
        lastVal = ObjectField();
jjtn000.values.add(lastVal);
      }
      jj_consume_token(CCBR);
jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public ObjectValueWithVariable ObjectValueWithVariable() throws ParseException {/*@bgen(jjtree) ObjectValueWithVariable */
    ObjectValueWithVariable jjtn000 = new ObjectValueWithVariable(JJTOBJECTVALUEWITHVARIABLE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();

    ObjectFieldWithValue lastVal;
    try {
      jj_consume_token(OCBR);
      label_8:
      while (true) {
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[29] = jj_gen;
          break label_8;
        }
        lastVal = ObjectFieldWithValue();
jjtn000.values.add(lastVal);
      }
      jj_consume_token(CCBR);
jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public ObjectField ObjectField() throws ParseException {/*@bgen(jjtree) ObjectField */
    ObjectField jjtn000 = new ObjectField(JJTOBJECTFIELD);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.name = Name();
      jj_consume_token(COLON);
      jjtn000.value = Value();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public ObjectFieldWithValue ObjectFieldWithValue() throws ParseException {/*@bgen(jjtree) ObjectFieldWithValue */
    ObjectFieldWithValue jjtn000 = new ObjectFieldWithValue(JJTOBJECTFIELDWITHVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.name = Name();
      jj_consume_token(COLON);
      jjtn000.value = ValueWithVariable();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

// Directives
  final public Directives Directives() throws ParseException {/*@bgen(jjtree) Directives */
    Directives jjtn000 = new Directives(JJTDIRECTIVES);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();

    Directive lastDirective;
    try {
      jj_consume_token(AT);
      lastDirective = Directive();
jjtn000.directives.add(lastDirective);
      label_9:
      while (true) {
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case AT:{
          break;
          }
        default:
          jj_la1[30] = jj_gen;
          break label_9;
        }
        jj_consume_token(AT);
        lastDirective = Directive();
jjtn000.directives.add(lastDirective);
      }

jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Directive Directive() throws ParseException {/*@bgen(jjtree) Directive */
    Directive jjtn000 = new Directive(JJTDIRECTIVE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.name = Name();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case OPAR:{
        jjtn000.arguments = Arguments();
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

// Types
  final public Type Type() throws ParseException {/*@bgen(jjtree) Type */
    Type jjtn000 = new Type(JJTTYPE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case FRAGMENT:
      case QUERY:
      case MUTATION:
      case SCHEMA:
      case SCALAR:
      case TYPE:
      case INTERFACE:
      case IMPLEMENTS:
      case ENUM:
      case UNION:
      case INPUT:
      case EXTEND:
      case DIRECTIVE:
      case NAME_LITERAL:{
        jjtn000.typeName = TypeName();
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case BANG:{
          jj_consume_token(BANG);
jjtn000.bang = true;
          break;
          }
        default:
          jj_la1[32] = jj_gen;
          ;
        }
        break;
        }
      case OBRA:{
        jjtn000.listType = ListType();
        break;
        }
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public TypeName TypeName() throws ParseException {/*@bgen(jjtree) TypeName */
  TypeName jjtn000 = new TypeName(JJTTYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      jjtn000.name = Name();
jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public ListType ListType() throws ParseException {/*@bgen(jjtree) ListType */
    ListType jjtn000 = new ListType(JJTLISTTYPE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jj_consume_token(OBRA);
      jjtn000.type = Type();
      jj_consume_token(CBRA);
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case BANG:{
        jj_consume_token(BANG);
jjtn000.bang = true;
        break;
        }
      default:
        jj_la1[34] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

// Type System
  final public TypeSystemDefinition TypeSystemDefinition() throws ParseException {/*@bgen(jjtree) TypeSystemDefinition */
  TypeSystemDefinition jjtn000 = new TypeSystemDefinition(JJTTYPESYSTEMDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case SCHEMA:{
        jjtn000.schemaDefinition = SchemaDefinition();
        break;
        }
      case SCALAR:
      case TYPE:
      case INTERFACE:
      case ENUM:
      case UNION:
      case INPUT:{
        jjtn000.typeDefinition = TypeDefinition();
        break;
        }
      case EXTEND:{
        jjtn000.typeExtensionDefinition = TypeExtensionDefinition();
        break;
        }
      case DIRECTIVE:{
        jjtn000.directiveDefinition = DirectiveDefinition();
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public SchemaDefinition SchemaDefinition() throws ParseException {/*@bgen(jjtree) SchemaDefinition */
    SchemaDefinition jjtn000 = new SchemaDefinition(JJTSCHEMADEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    OperationTypeDefinition lastOpTypeDef;
    try {
      jj_consume_token(SCHEMA);
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      jj_consume_token(OCBR);
      label_10:
      while (true) {
        lastOpTypeDef = OperationTypeDefinition();
jjtn000.operationTypeDefinitions.add(lastOpTypeDef);
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case QUERY:
        case MUTATION:{
          break;
          }
        default:
          jj_la1[37] = jj_gen;
          break label_10;
        }
      }
      jj_consume_token(CCBR);
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public OperationTypeDefinition OperationTypeDefinition() throws ParseException {/*@bgen(jjtree) OperationTypeDefinition */
    OperationTypeDefinition jjtn000 = new OperationTypeDefinition(JJTOPERATIONTYPEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.operationType = OperationType();
      jj_consume_token(COLON);
      jjtn000.typeName = TypeName();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public TypeDefinition TypeDefinition() throws ParseException {/*@bgen(jjtree) TypeDefinition */
    TypeDefinition jjtn000 = new TypeDefinition(JJTTYPEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));TypeDefinition result;
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case SCALAR:{
        result = ScalarTypeDefinition();
        break;
        }
      case TYPE:{
        result = ObjectTypeDefinition();
        break;
        }
      case INTERFACE:{
        result = InterfaceTypeDefinition();
        break;
        }
      case UNION:{
        result = UnionTypeDefinition();
        break;
        }
      case ENUM:{
        result = EnumTypeDefinition();
        break;
        }
      case INPUT:{
        result = InputObjectTypeDefinition();
        break;
        }
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return result;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public ScalarTypeDefinition ScalarTypeDefinition() throws ParseException {/*@bgen(jjtree) ScalarTypeDefinition */
    ScalarTypeDefinition jjtn000 = new ScalarTypeDefinition(JJTSCALARTYPEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jj_consume_token(SCALAR);
      jjtn000.name = Name();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[39] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public ObjectTypeDefinition ObjectTypeDefinition() throws ParseException {/*@bgen(jjtree) ObjectTypeDefinition */
    ObjectTypeDefinition jjtn000 = new ObjectTypeDefinition(JJTOBJECTTYPEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    FieldDefinition lastFieldDef;
    try {
      jj_consume_token(TYPE);
      jjtn000.name = Name();

      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case IMPLEMENTS:{
        jjtn000.implementsInterface = ImplementsInterface();
        break;
        }
      default:
        jj_la1[40] = jj_gen;
        ;
      }
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      jj_consume_token(OCBR);
      label_11:
      while (true) {
        lastFieldDef = FieldDefinition();
jjtn000.fieldDefinitions.add(lastFieldDef);
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[42] = jj_gen;
          break label_11;
        }
      }
      jj_consume_token(CCBR);
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public ImplementsInterface ImplementsInterface() throws ParseException {/*@bgen(jjtree) ImplementsInterface */
    ImplementsInterface jjtn000 = new ImplementsInterface(JJTIMPLEMENTSINTERFACE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));TypeName lastTypeName;
    try {
      jj_consume_token(IMPLEMENTS);
      label_12:
      while (true) {
        lastTypeName = TypeName();
jjtn000.typeNames.add(lastTypeName);
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[43] = jj_gen;
          break label_12;
        }
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public FieldDefinition FieldDefinition() throws ParseException {/*@bgen(jjtree) FieldDefinition */
    FieldDefinition jjtn000 = new FieldDefinition(JJTFIELDDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.name = Name();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case OPAR:{
        jjtn000.argumentsDefinition = ArgumentsDefinition();
        break;
        }
      default:
        jj_la1[44] = jj_gen;
        ;
      }
      jj_consume_token(COLON);
      jjtn000.type = Type();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[45] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public ArgumentsDefinition ArgumentsDefinition() throws ParseException {/*@bgen(jjtree) ArgumentsDefinition */
    ArgumentsDefinition jjtn000 = new ArgumentsDefinition(JJTARGUMENTSDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();

    InputValueDefinition lastVal;
    try {
      jj_consume_token(OPAR);
      label_13:
      while (true) {
        lastVal = InputValueDefinition();
jjtn000.inputValueDefinitions.add(lastVal);
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[46] = jj_gen;
          break label_13;
        }
      }
      jj_consume_token(CPAR);
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public InputValueDefinition InputValueDefinition() throws ParseException {/*@bgen(jjtree) InputValueDefinition */
    InputValueDefinition jjtn000 = new InputValueDefinition(JJTINPUTVALUEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.name = Name();
      jj_consume_token(COLON);
      jjtn000.type = Type();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case EQ:{
        jjtn000.defaultValue = DefaultValue();
        break;
        }
      default:
        jj_la1[47] = jj_gen;
        ;
      }
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public InterfaceTypeDefinition InterfaceTypeDefinition() throws ParseException {/*@bgen(jjtree) InterfaceTypeDefinition */
    InterfaceTypeDefinition jjtn000 = new InterfaceTypeDefinition(JJTINTERFACETYPEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    FieldDefinition lastFieldDef;
    try {
      jj_consume_token(INTERFACE);
      jjtn000.name = Name();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      jj_consume_token(OCBR);
      label_14:
      while (true) {
        lastFieldDef = FieldDefinition();
jjtn000.fieldDefinitions.add(lastFieldDef);
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[50] = jj_gen;
          break label_14;
        }
      }
      jj_consume_token(CCBR);
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public UnionTypeDefinition UnionTypeDefinition() throws ParseException {/*@bgen(jjtree) UnionTypeDefinition */
    UnionTypeDefinition jjtn000 = new UnionTypeDefinition(JJTUNIONTYPEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jj_consume_token(UNION);
      jjtn000.name = Name();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      jj_consume_token(EQ);
      jjtn000.unionMembers = UnionMembers();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public UnionMembers UnionMembers() throws ParseException {/*@bgen(jjtree) UnionMembers */
    UnionMembers jjtn000 = new UnionMembers(JJTUNIONMEMBERS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();

    TypeName lastTypeName;
    try {
      lastTypeName = TypeName();
jjtn000.typeNames.add(lastTypeName);
      label_15:
      while (true) {
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case PIPE:{
          break;
          }
        default:
          jj_la1[52] = jj_gen;
          break label_15;
        }
        jj_consume_token(PIPE);
        lastTypeName = TypeName();
jjtn000.typeNames.add(lastTypeName);
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public EnumTypeDefinition EnumTypeDefinition() throws ParseException {/*@bgen(jjtree) EnumTypeDefinition */
    EnumTypeDefinition jjtn000 = new EnumTypeDefinition(JJTENUMTYPEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    EnumValueDefinition lastEnumValDef;
    try {
      jj_consume_token(ENUM);
      jjtn000.name = Name();

      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[53] = jj_gen;
        ;
      }
      jj_consume_token(OCBR);
      label_16:
      while (true) {
        lastEnumValDef = EnumValueDefinition();
jjtn000.enumValueDefinitions.add(lastEnumValDef);
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[54] = jj_gen;
          break label_16;
        }
      }
      jj_consume_token(CCBR);
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public EnumValueDefinition EnumValueDefinition() throws ParseException {/*@bgen(jjtree) EnumValueDefinition */
    EnumValueDefinition jjtn000 = new EnumValueDefinition(JJTENUMVALUEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.enumValue = EnumValue();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[55] = jj_gen;
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public InputObjectTypeDefinition InputObjectTypeDefinition() throws ParseException {/*@bgen(jjtree) InputObjectTypeDefinition */
    InputObjectTypeDefinition jjtn000 = new InputObjectTypeDefinition(JJTINPUTOBJECTTYPEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();

    InputValueDefinition lastInputValDef;
    try {
      jj_consume_token(INPUT);
      jjtn000.name = Name();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case AT:{
        jjtn000.directives = Directives();
        break;
        }
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      jj_consume_token(OCBR);
      label_17:
      while (true) {
        lastInputValDef = InputValueDefinition();
jjtn000.inputValueDefinitions.add(lastInputValDef);
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case FRAGMENT:
        case QUERY:
        case MUTATION:
        case SCHEMA:
        case SCALAR:
        case TYPE:
        case INTERFACE:
        case IMPLEMENTS:
        case ENUM:
        case UNION:
        case INPUT:
        case EXTEND:
        case DIRECTIVE:
        case NAME_LITERAL:{
          break;
          }
        default:
          jj_la1[57] = jj_gen;
          break label_17;
        }
      }
      jj_consume_token(CCBR);
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public TypeExtensionDefinition TypeExtensionDefinition() throws ParseException {/*@bgen(jjtree) TypeExtensionDefinition */
    TypeExtensionDefinition jjtn000 = new TypeExtensionDefinition(JJTTYPEEXTENSIONDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jj_consume_token(EXTEND);
      jjtn000.objectTypeDefinition = ObjectTypeDefinition();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public DirectiveDefinition DirectiveDefinition() throws ParseException {/*@bgen(jjtree) DirectiveDefinition */
    DirectiveDefinition jjtn000 = new DirectiveDefinition(JJTDIRECTIVEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jj_consume_token(DIRECTIVE);
      jj_consume_token(AT);
      jjtn000.name = Name();
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case OPAR:{
        jjtn000.argumentsDefinition = ArgumentsDefinition();
        break;
        }
      default:
        jj_la1[58] = jj_gen;
        ;
      }
      jj_consume_token(ON);
      jjtn000.directiveLocations = DirectiveLocations();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public DirectiveLocation DirectiveLocation() throws ParseException {/*@bgen(jjtree) DirectiveLocation */
    DirectiveLocation jjtn000 = new DirectiveLocation(JJTDIRECTIVELOCATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      jjtn000.name = Name();
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public DirectiveLocations DirectiveLocations() throws ParseException {/*@bgen(jjtree) DirectiveLocations */
    DirectiveLocations jjtn000 = new DirectiveLocations(JJTDIRECTIVELOCATIONS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    DirectiveLocation lastDirLocation;
    try {
      lastDirLocation = DirectiveLocation();
jjtn000.directiveLocations.add(lastDirLocation);
      label_18:
      while (true) {
        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
        case PIPE:{
          break;
          }
        default:
          jj_la1[59] = jj_gen;
          break label_18;
        }
        jj_consume_token(PIPE);
        lastDirLocation = DirectiveLocation();
jjtn000.directiveLocations.add(lastDirLocation);
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

// Tokens
  final public BooleanValue BooleanValue() throws ParseException {/*@bgen(jjtree) BooleanValue */
    BooleanValue jjtn000 = new BooleanValue(JJTBOOLEANVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case TRUE:{
        jj_consume_token(TRUE);
jjtn000.val = true;
        break;
        }
      case FALSE:{
        jj_consume_token(FALSE);
jjtn000.val = false;
        break;
        }
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public IntValue IntValue() throws ParseException {/*@bgen(jjtree) IntValue */
    IntValue jjtn000 = new IntValue(JJTINTVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    Token literal;
    try {
      literal = jj_consume_token(INTEGER_LITERAL);
jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                  jjtn000.jjtSetLastToken(getToken(0));
jjtn000.val = Integer.parseInt(literal.image);
        {if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public FloatValue FloatValue() throws ParseException {/*@bgen(jjtree) FloatValue */
    FloatValue jjtn000 = new FloatValue(JJTFLOATVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    Token literal;
    try {
      literal = jj_consume_token(FLOAT_LITERAL);
jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                                jjtn000.jjtSetLastToken(getToken(0));
jjtn000.stringValue = literal.image;
        //TODO parse!
        {if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public StringValue StringValue() throws ParseException {/*@bgen(jjtree) StringValue */
    StringValue jjtn000 = new StringValue(JJTSTRINGVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));int tokenId = tokenId();
    int line = line();
    int column = column();
    Token literal;
    try {
      literal = jj_consume_token(STRING_LITERAL);
jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                                 jjtn000.jjtSetLastToken(getToken(0));
jjtn000.val = literal.image;
        {if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public OperationType OperationType() throws ParseException {/*@bgen(jjtree) OperationType */
  OperationType jjtn000 = new OperationType(JJTOPERATIONTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
    try {
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case MUTATION:{
        jj_consume_token(MUTATION);
jjtn000.mutation = true;
        break;
        }
      case QUERY:{
        jj_consume_token(QUERY);
jjtn000.query = true;
        break;
        }
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
{if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  /** Generated Token Manager. */
  public GraphQLParserTokenManager token_source;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[62];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0xfbf82000,0xfbf82000,0xfff80000,0x20,0x400,0x302000,0x10,0x200,0xfff80080,0x100,0xfff82400,0xfff80080,0x20,0x400,0x2000,0x20,0x400,0x2000,0x2,0x400,0x0,0x400,0x400,0xfff80000,0xfff82800,0xfff82810,0xfff82800,0xfff82810,0xfff80000,0xfff80000,0x400,0x20,0x8,0xfff80800,0x8,0xfbc00000,0x400,0x300000,0x3b800000,0x400,0x4000000,0x400,0xfff80000,0xfff80000,0x20,0x400,0xfff80000,0x200,0x400,0x400,0xfff80000,0x400,0x4000,0x400,0xfff80000,0x400,0x400,0xfff80000,0x20,0x4000,0x0,0x300000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x400008,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x400000,0x780003,0x780003,0x780003,0x780003,0x400000,0x400000,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x400000,0x0,0x0,0x400000,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x400000,0x0,0x0,0x400000,0x0,0x0,0x3,0x0,};
	}

  /**
   * Constructor with user supplied CharStream.
   * @param stream stream to init with
   */
  public GraphQLParser(final CharStream stream) {
	 token_source = new GraphQLParserTokenManager(stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 62; i++) jj_la1[i] = -1;
  }

  /**
   * Reinitialise.
   * @param stream stream to init with
   */
  public void ReInit(final CharStream stream) {
	 token_source.ReInit(stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
   for (int i = 0; i < 62; i++)
     jj_la1[i] = -1;
  }

  /**
   * Constructor with generated Token Manager.
   * @param tm Token manager to use
   */
  public GraphQLParser(final GraphQLParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 62; i++) jj_la1[i] = -1;
  }

  /**
   * Reinitialise
   * @param tm Token manager to use
   */
  public void ReInit(final GraphQLParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 62; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(final int kind) throws ParseException {
    final Token oldToken = token;
    if (token.next != null)
      token = token.next;
    else {
      token.next = token_source.getNextToken();
      token = token.next;
    }
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


  /**
   * @return the next Token.
   */
  public final Token getNextToken() {
   if (token.next != null)
     token = token.next;
   else
     token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

  /**
   * @param index index to be retrieved
   * @return the specific Token.
   */
  public final Token getToken(final int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next == null)
        t.next = token_source.getNextToken();
      t = t.next;
    }
    return t;
  }

  private int jj_ntk_f() {
    jj_nt = token.next;
    if (jj_nt == null) {
      token.next = token_source.getNextToken();
      jj_ntk = token.next.kind;
      return jj_ntk;
    }
    jj_ntk = jj_nt.kind;
    return jj_ntk;
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /**
   * Generate ParseException.
   * @return new Exception object. Never <code>null</code>
   */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[55];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 62; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 55; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /**
   * @return Always <code>false</code>.
   */
  public final boolean trace_enabled() {
    return false;
  }

  /** Enable tracing. */
  public final void enable_tracing() {}

  /** Disable tracing. */
  public final void disable_tracing() {}

}
