#!/usr/bin/env python3
"""
Example 01: Simple Document Store

This example demonstrates the absolute basics of ArcadeDB Python bindings:
- Creating an embedded database (no server needed!)
- Defining document types (schema) with various data types
- CRUD operations (Create, Read, Update, Delete)
- Using transactions safely
- Querying with ArcadeDB SQL (a dialect of SQL)

Perfect for: Configuration storage, logs, simple app data, desktop applications
Think of it as: SQLite but for documents with flexible schema

Record Types Used:
- DOCUMENT TYPE only (simplest data storage, like SQL tables but more flexible)
- Not using VERTEX/EDGE types (those are for graph operations)

Requirements:
- arcadedb-embedded

Note: This example creates a database at ./my_test_databases/task_db/
      The database files are preserved so you can inspect them after running.

About ArcadeDB SQL:
This example uses ArcadeDB's SQL dialect, which extends standard SQL with:
- Document operations (INSERT/UPDATE with JSON-like syntax)
- Built-in functions like date(), sysDate(), uuid()
- Rich data type support (DATE, DATETIME, DECIMAL, BINARY, etc.)
- Schema-flexible operations alongside typed properties
- No JOINs - relationships use LINKS with dot notation (e.g., user.address.city)
"""

import os
import shutil
import time
import uuid
from datetime import date, datetime

import arcadedb_embedded as arcadedb

print("=" * 70)
print("üéÆ ArcadeDB Python - Example 01: Simple Document Store")
print("=" * 70)
print()

# -----------------------------------------------------------------------------
# Step 1: Create Database
# -----------------------------------------------------------------------------
print("Step 1: Creating database...")
print()

step_start = time.time()

# Create database in a local directory so you can inspect the files
# This creates: ./my_test_databases/task_db/
db_dir = "./my_test_databases"
db_path = os.path.join(db_dir, "task_db")

# Clean up any existing database from previous runs
if os.path.exists(db_path):
    shutil.rmtree(db_path)

# Clean up log directory from previous runs
if os.path.exists("./log"):
    shutil.rmtree("./log")

with arcadedb.create_database(db_path) as db:

    print(f"   ‚úÖ Database created at: {db_path}")
    print("   üí° Using embedded mode - no server needed!")
    print("   üí° Database files are kept so you can inspect them!")
    print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
    print()

    # -----------------------------------------------------------------------------
    # Step 2: Create Schema (Document Type with Rich Data Types)
    # -----------------------------------------------------------------------------
    print("Step 2: Creating schema with various data types...")
    print()

    step_start = time.time()

    # ArcadeDB has 3 record types: Document, Vertex, and Edge
    # - Document: Simple data storage (like SQL tables but more flexible)
    # - Vertex: Graph nodes for graph operations
    # - Edge: Graph connections between vertices
    # This example uses DOCUMENT TYPE - the simplest way to store data
    print("   üí° ArcadeDB Record Types:")
    print("      ‚Ä¢ Document: Simple data storage (what we're using)")
    print("      ‚Ä¢ Vertex: Graph nodes for graph operations")
    print("      ‚Ä¢ Edge: Graph connections between vertices")
    print()

    # While ArcadeDB is schema-flexible, defining types is recommended
    # It provides better performance, validation, and indexing
    # Schema operations are auto-transactional (no wrapper needed)
    db.schema.create_document_type("Task")

    # Define properties with various ArcadeDB data types
    db.schema.create_property("Task", "title", "STRING")  # Text
    db.schema.create_property("Task", "priority", "STRING")  # Text
    db.schema.create_property("Task", "completed", "BOOLEAN")  # True/False
    db.schema.create_property(
        "Task", "tags", "LIST", of_type="STRING"
    )  # Array of strings
    db.schema.create_property("Task", "created_date", "DATE")  # Date only
    db.schema.create_property("Task", "due_datetime", "DATETIME")  # Date + time
    db.schema.create_property("Task", "estimated_hours", "FLOAT")  # Decimal
    db.schema.create_property("Task", "priority_score", "INTEGER")  # Integer
    db.schema.create_property("Task", "cost", "DECIMAL")  # Precision
    db.schema.create_property("Task", "task_id", "STRING")  # Generated by uuid()

    print("   ‚úÖ Created 'Task' document type with rich data types")
    print("   üí° ArcadeDB supports: STRING, BOOLEAN, INTEGER, LONG, FLOAT, DOUBLE,")
    print("                        DATE, DATETIME, DATETIME_MICROS, DATETIME_NANOS,")
    print("                        DECIMAL, BINARY, EMBEDDED, LINK, and Arrays")
    print("   üí° Note: UUIDs are stored as STRING type, RIDs use LINK type")
    print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
    print()

    # -----------------------------------------------------------------------------
    # Step 3: INSERT - Create Documents
    # -----------------------------------------------------------------------------
    print("Step 3: Inserting documents...")
    print()

    step_start = time.time()

    # IMPORTANT: All write operations must be inside a transaction!
    # Transactions ensure ACID guarantees (Atomicity, Consistency, Isolation, Durability)
    with db.transaction():
        # Insert task with full data types (using all defined properties) via Document API
        task = db.new_document("Task")
        task.set("title", "Buy groceries")
        task.set("priority", "high")
        task.set("completed", False)
        task.set("tags", ["shopping", "urgent"])
        task.set("created_date", date(2024, 1, 15))
        task.set("due_datetime", datetime(2024, 1, 20, 18, 0, 0))
        task.set("estimated_hours", 2.5)
        task.set("priority_score", 90)
        task.set("cost", 150.00)
        task.set("task_id", str(uuid.uuid4()))
        task.save()

        # Insert task with some NULL values (optional fields)
        task = db.new_document("Task")
        task.set("title", "Write documentation")
        task.set("priority", "medium")
        task.set("completed", False)
        task.set("tags", ["work", "writing"])
        task.set("created_date", date(2024, 1, 16))
        task.set("due_datetime", None)
        task.set("estimated_hours", 8.0)
        task.set("priority_score", 70)
        task.set("cost", None)
        task.set("task_id", str(uuid.uuid4()))
        task.save()

        # Insert completed task with all fields
        task = db.new_document("Task")
        task.set("title", "Call dentist")
        task.set("priority", "low")
        task.set("completed", True)
        task.set("tags", ["personal", "health"])
        task.set("created_date", date(2024, 1, 10))
        task.set("due_datetime", datetime(2024, 1, 12, 10, 30, 0))
        task.set("estimated_hours", 0.5)
        task.set("priority_score", 30)
        task.set("cost", 0.00)
        task.set("task_id", str(uuid.uuid4()))
        task.save()

        # Insert task with many NULL fields (minimal required data)
        task = db.new_document("Task")
        task.set("title", "Research ArcadeDB features")
        task.set("priority", "medium")
        task.set("completed", False)
        task.set("tags", ["work", "research"])
        task.set("created_date", date(2024, 1, 17))
        task.set("due_datetime", None)
        task.set("estimated_hours", None)
        task.set("priority_score", 60)
        task.set("cost", None)
        task.set("task_id", str(uuid.uuid4()))
        task.save()

        # Note: Arrays (lists) work naturally - no need for JSON serialization!
        # NULL values represent optional/missing data
        # uuid() generates unique identifiers automatically
        # Documents can contain: strings, numbers, booleans, arrays, nested objects, NULLs

    print("   ‚úÖ Inserted 4 tasks (with various data types and NULL values)")
    print("   üí° Transaction committed automatically at end of 'with' block")
    print("   üí° NULL values used for optional fields (due_datetime, cost, etc.)")
    print("   üí° Python uuid4() generates unique task IDs")
    print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
    print()

    # -----------------------------------------------------------------------------
    # Step 4: QUERY - Read Documents
    # -----------------------------------------------------------------------------
    print("Step 4: Querying documents...")
    print()

    step_start = time.time()

    # Query all tasks with all properties
    print("   üìã All tasks (with automatic type conversion):")
    result = db.query("sql", "SELECT FROM Task ORDER BY priority_score DESC")

    # Using the new first() method and automatic type conversion
    for record in result:
        # Automatic type conversion: no more Java objects!
        title = record.get("title")  # Now returns Python str directly
        priority = record.get("priority")  # Python str
        completed = record.get("completed")  # Python bool
        estimated_hours = record.get("estimated_hours")  # Python float or None
        cost = record.get("cost")  # Python Decimal or None
        due = record.get("due_datetime")  # Python datetime or None
        task_id = record.get("task_id")  # Python str

        status = "‚úÖ" if completed else "‚è≥"

        # Handle None values (much cleaner than NULL handling!)
        hours_str = f"{estimated_hours}h" if estimated_hours is not None else "N/A"
        cost_str = f"${float(cost):.2f}" if cost is not None else "N/A"
        due_str = str(due)[:10] if due is not None else "No deadline"

        print(f"      {status} [{priority:6}] {title}")
        print(f"         Time: {hours_str}, Cost: {cost_str}, Due: {due_str}")
        print(f"         UUID: {task_id}")

    print()
    print("   üí° NEW: Automatic type conversion!")
    print("      ‚Ä¢ get() now returns native Python types")
    print("      ‚Ä¢ No more Java objects (Integer, BigDecimal, etc.)")
    print("      ‚Ä¢ Decimals are Python Decimal, dates are datetime")

    print()

    # Query with WHERE clause - find incomplete high priority tasks
    print("   üî• High priority incomplete tasks:")
    result = db.query(
        "sql", "SELECT FROM Task WHERE priority = 'high' AND completed = false"
    )

    # Using new to_list() for efficient bulk conversion
    tasks = result.to_list()  # Convert all to list of dicts in one operation

    for task in tasks:
        title = task["title"]
        tags = task["tags"]  # Automatically converted to Python list!
        print(f"      ‚Ä¢ {title}")
        print(f"        Tags: {', '.join(tags)}")

    if not tasks:
        print("      (none found)")
    else:
        print(f"      üí° Used to_list() for efficient bulk conversion")

    print()

    # Query for tasks with NULL values (no deadline)
    print("   ‚è∞ Tasks without deadlines (due_datetime IS NULL):")
    result = db.query("sql", "SELECT FROM Task WHERE due_datetime IS NULL")

    count = 0
    for record in result:
        title = str(record.get("title"))
        priority = str(record.get("priority"))
        print(f"      ‚Ä¢ [{priority}] {title}")
        count += 1

    if count == 0:
        print("      (none found)")
    else:
        print(f"      üí° Found {count} task(s) with NULL deadline")

    print()

    # Query for tasks with NULL cost
    print("   üí∞ Tasks without cost estimate (cost IS NULL):")
    result = db.query("sql", "SELECT FROM Task WHERE cost IS NULL")

    count = 0
    for record in result:
        title = str(record.get("title"))
        print(f"      ‚Ä¢ {title}")
        count += 1

    if count == 0:
        print("      (none found)")
    else:
        print(f"      üí° Found {count} task(s) with NULL cost")

    print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
    print()

    # -----------------------------------------------------------------------------
    # Step 5: UPDATE - Modify Documents (including setting NULL)
    # -----------------------------------------------------------------------------
    print("Step 5: Updating documents...")
    print()

    step_start = time.time()

    # Mark 'Buy groceries' as completed and add actual cost
    with db.transaction():
        db.command(
            "sql",
            """UPDATE Task SET
               completed = true,
               cost = 127.50
               WHERE title = 'Buy groceries'""",
        )

    print("   ‚úÖ Marked 'Buy groceries' as completed and set actual cost")
    print()

    # Update a task to set NULL value (cancel cost estimate)
    with db.transaction():
        db.command(
            "sql",
            """UPDATE Task SET
               cost = NULL,
               estimated_hours = NULL
               WHERE title = 'Call dentist'""",
        )

    print("   ‚úÖ Cleared cost and time estimates for 'Call dentist' (set to NULL)")
    print()

    # Verify the updates
    print("   üìä Updated task list (with NULL handling):")
    result = db.query("sql", "SELECT FROM Task ORDER BY completed, priority_score DESC")

    for record in result:
        title = str(record.get("title"))
        priority = str(record.get("priority"))
        completed = record.get("completed")
        cost = record.get("cost")
        estimated_hours = record.get("estimated_hours")

        status = "‚úÖ" if completed else "‚è≥"

        # Show how NULL values appear (convert DECIMAL via string to float)
        if cost is not None:
            cost_str = f"${float(str(cost)):.2f}"
        else:
            cost_str = "NULL"
        hours_str = f"{estimated_hours}h" if estimated_hours is not None else "NULL"

        print(f"      {status} [{priority:6}] {title}")
        print(f"         Cost: {cost_str}, Hours: {hours_str}")

    print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
    print()

    # -----------------------------------------------------------------------------
    # Step 6: Advanced Queries
    # -----------------------------------------------------------------------------
    print("Step 6: Running aggregation queries...")
    print()

    step_start = time.time()

    # Count total tasks using new count_type() method
    total = db.count_type("Task")  # Efficient count without loading data
    print(f"   üìä Total tasks: {total}")
    print("      üí° Using new count_type() method (faster than COUNT query)")
    print()

    # Count by priority
    result = db.query(
        "sql", "SELECT priority, count(*) as count FROM Task GROUP BY priority"
    )
    print("   üìä Tasks by priority:")
    for record in result:
        priority = str(record.get("priority"))
        count = record.get("count")
        print(f"      ‚Ä¢ {priority}: {count}")

    # Count completed vs incomplete
    result = db.query(
        "sql", "SELECT completed, count(*) as count FROM Task GROUP BY completed"
    )
    print("   üìä Completion status:")
    # Using first() and iteration
    for record in result:
        completed = record.get("completed")
        count = record.get("count")
        status = "Completed" if completed else "Incomplete"
        print(f"      ‚Ä¢ {status}: {count}")

    print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
    print()

    # Demonstrate new ResultSet features
    print("   üí° New ResultSet features demonstrated:")
    print("      ‚Ä¢ to_list() - bulk conversion to list of dicts")
    print("      ‚Ä¢ first() - get first result or None")
    print("      ‚Ä¢ count_type() - efficient record counting")
    print("      ‚Ä¢ Automatic type conversion (no more Java objects!)")

    print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
    print()

    # -----------------------------------------------------------------------------
    # üí° ArcadeDB SQL Key Difference: No JOINs
    # -----------------------------------------------------------------------------
    print("üí° ArcadeDB SQL Key Difference: No JOINs")
    print()
    print("   ArcadeDB uses LINKS instead of JOINs for relationships.")
    print("   Instead of traditional JOIN syntax, use dot notation:")
    print()
    print("   ‚ùå Traditional SQL (not supported):")
    print("      SELECT * FROM Employee A, City B")
    print("      WHERE A.city = B.id AND B.name = 'Rome'")
    print()
    print("   ‚úÖ ArcadeDB SQL (dot notation):")
    print("      SELECT * FROM Employee WHERE city.name = 'Rome'")
    print()
    print("   This makes queries simpler and more intuitive!")
    print()

    # -----------------------------------------------------------------------------
    # Step 7: DELETE - Remove Documents
    # -----------------------------------------------------------------------------
    print("Step 7: Deleting documents...")
    print()

    # Delete completed tasks
    with db.transaction():
        result = db.command("sql", "DELETE FROM Task WHERE completed = true")

    print("   üóëÔ∏è  Deleted all completed tasks")
    print()

    # Verify deletion
    result = db.query("sql", "SELECT count(*) as remaining FROM Task")
    remaining = list(result)[0].get("remaining")
    print(f"   üìä Remaining tasks: {remaining}")
    print()

    # Show remaining tasks
    print("   üìã Remaining tasks:")
    result = db.query("sql", "SELECT FROM Task ORDER BY priority DESC")

    for record in result:
        title = str(record.get("title"))
        priority = str(record.get("priority"))
        print(f"      ‚è≥ [{priority:6}] {title}")

    print()

    # -----------------------------------------------------------------------------
    # Step 8: Cleanup
    # -----------------------------------------------------------------------------
    print("Step 8: Cleanup...")
    print()

    # Close database connection
print("   ‚úÖ Database closed")

# Note: We're NOT deleting the database directory
# You can inspect the files in ./my_test_databases/task_db/
print(f"   üí° Database files preserved at: {db_path}")
print("   üí° Inspect the database structure and files!")
print("   üí° Re-run this script to recreate the database")

print()
print("=" * 70)
print("‚úÖ Example Complete!")
print("=" * 70)
print()
print("üìö What you learned:")
print("   ‚Ä¢ Creating embedded databases (no server needed)")
print("   ‚Ä¢ Using context managers for transactions")
print("   ‚Ä¢ CRUD operations (Document API + SQL)")
print("   ‚Ä¢ Querying and filtering data")
print("   ‚Ä¢ Working with flexible document schema")
print()
print("üí° Files created:")
print("   ‚Ä¢ ./my_test_databases/task_db/ - Database files:")
print("     - configuration.json - Database configuration")
print("     - schema.json - Schema definition (types & properties)")
print("     - Task_0.1.65536.v0.bucket - Data bucket with Task documents")
print("     - dictionary.0.327680.v0.dict - String compression dictionary")
print("     - statistics.json - Database statistics")
print("   ‚Ä¢ ./log/ - ArcadeDB and JVM log files")
print()
print("üí° Next steps:")
print("   ‚Ä¢ See docs/examples/ for detailed explanations")
print("   ‚Ä¢ See docs/guide/operations.md for file structure and logging")
print()
print("üîó API Documentation:")
print("   ‚Ä¢ Database: docs/api/database.md")
print("   ‚Ä¢ Transactions: docs/api/transactions.md")
print("   ‚Ä¢ Results: docs/api/results.md")
print()
