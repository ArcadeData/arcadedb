#!/usr/bin/env python3
"""
Example 01: Simple Document Store

This example demonstrates the absolute basics of ArcadeDB Python bindings:
- Creating an embedded database (no server needed!)
- Defining document types (schema) with various data types
- CRUD operations (Create, Read, Update, Delete)
- Using transactions safely
- Querying with ArcadeDB SQL (a dialect of SQL)

Perfect for: Configuration storage, logs, simple app data, desktop applications
Think of it as: SQLite but for documents with flexible schema

Record Types Used:
- DOCUMENT TYPE only (simplest data storage, like SQL tables but more flexible)
- Not using VERTEX/EDGE types (those are for graph operations)

Requirements:
- arcadedb-embedded (any distribution: headless, minimal, or full)
- JRE 21+

Note: This example creates a database at ./my_test_databases/task_db/
      The database files are preserved so you can inspect them after running.

About ArcadeDB SQL:
This example uses ArcadeDB's SQL dialect, which extends standard SQL with:
- Document operations (INSERT/UPDATE with JSON-like syntax)
- Built-in functions like date(), sysDate(), uuid()
- Rich data type support (DATE, DATETIME, DECIMAL, BINARY, etc.)
- Schema-flexible operations alongside typed properties
- No JOINs - relationships use LINKS with dot notation (e.g., user.address.city)
"""

import os
import shutil
import time

import arcadedb_embedded as arcadedb

print("=" * 70)
print("üéÆ ArcadeDB Python - Example 01: Simple Document Store")
print("=" * 70)
print()

# -----------------------------------------------------------------------------
# Step 1: Create Database
# -----------------------------------------------------------------------------
print("Step 1: Creating database...")
print()

step_start = time.time()

# Create database in a local directory so you can inspect the files
# This creates: ./my_test_databases/task_db/
db_dir = "./my_test_databases"
db_path = os.path.join(db_dir, "task_db")

# Clean up any existing database from previous runs
if os.path.exists(db_path):
    shutil.rmtree(db_path)

# Clean up log directory from previous runs
if os.path.exists("./log"):
    shutil.rmtree("./log")

db = arcadedb.create_database(db_path)

print(f"   ‚úÖ Database created at: {db_path}")
print("   üí° Using embedded mode - no server needed!")
print("   üí° Database files are kept so you can inspect them!")
print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
print()

# -----------------------------------------------------------------------------
# Step 2: Create Schema (Document Type with Rich Data Types)
# -----------------------------------------------------------------------------
print("Step 2: Creating schema with various data types...")
print()

step_start = time.time()

# ArcadeDB has 3 record types: Document, Vertex, and Edge
# - Document: Simple data storage (like SQL tables but more flexible)
# - Vertex: Graph nodes for graph operations
# - Edge: Graph connections between vertices
# This example uses DOCUMENT TYPE - the simplest way to store data
print("   üí° ArcadeDB Record Types:")
print("      ‚Ä¢ Document: Simple data storage (what we're using)")
print("      ‚Ä¢ Vertex: Graph nodes for graph operations")
print("      ‚Ä¢ Edge: Graph connections between vertices")
print()

# While ArcadeDB is schema-flexible, defining types is recommended
# It provides better performance, validation, and indexing
with db.transaction():
    db.command("sql", "CREATE DOCUMENT TYPE Task")

    # Define properties with various ArcadeDB data types
    db.command("sql", "CREATE PROPERTY Task.title STRING")  # Text
    db.command("sql", "CREATE PROPERTY Task.priority STRING")  # Text
    db.command("sql", "CREATE PROPERTY Task.completed BOOLEAN")  # True/False
    db.command("sql", "CREATE PROPERTY Task.tags LIST OF STRING")  # Array of strings
    db.command("sql", "CREATE PROPERTY Task.created_date DATE")  # Date only
    db.command("sql", "CREATE PROPERTY Task.due_datetime DATETIME")  # Date + time
    db.command("sql", "CREATE PROPERTY Task.estimated_hours FLOAT")  # Decimal
    db.command("sql", "CREATE PROPERTY Task.priority_score INTEGER")  # Integer
    db.command("sql", "CREATE PROPERTY Task.cost DECIMAL")  # Precision
    db.command("sql", "CREATE PROPERTY Task.task_id STRING")  # Generated by uuid()

print("   ‚úÖ Created 'Task' document type with rich data types")
print("   üí° ArcadeDB supports: STRING, BOOLEAN, INTEGER, LONG, FLOAT, DOUBLE,")
print("                        DATE, DATETIME, DATETIME_MICROS, DATETIME_NANOS,")
print("                        DECIMAL, BINARY, EMBEDDED, LINK, and Arrays")
print("   üí° Note: UUIDs are stored as STRING type, RIDs use LINK type")
print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
print()

# -----------------------------------------------------------------------------
# Step 3: INSERT - Create Documents
# -----------------------------------------------------------------------------
print("Step 3: Inserting documents...")
print()

step_start = time.time()

# IMPORTANT: All write operations must be inside a transaction!
# Transactions ensure ACID guarantees (Atomicity, Consistency, Isolation, Durability)
with db.transaction():
    # Insert task with full data types (using all defined properties)
    db.command(
        "sql",
        """INSERT INTO Task SET
           title = 'Buy groceries',
           priority = 'high',
           completed = false,
           tags = ['shopping', 'urgent'],
           created_date = date('2024-01-15'),
           due_datetime = '2024-01-20 18:00:00',
           estimated_hours = 2.5,
           priority_score = 90,
           cost = 150.00,
           task_id = uuid()
        """,
    )

    # Insert task with some NULL values (optional fields)
    db.command(
        "sql",
        """INSERT INTO Task SET
           title = 'Write documentation',
           priority = 'medium',
           completed = false,
           tags = ['work', 'writing'],
           created_date = date('2024-01-16'),
           due_datetime = NULL,
           estimated_hours = 8.0,
           priority_score = 70,
           cost = NULL,
           task_id = uuid()
        """,
    )

    # Insert completed task with all fields
    db.command(
        "sql",
        """INSERT INTO Task SET
           title = 'Call dentist',
           priority = 'low',
           completed = true,
           tags = ['personal', 'health'],
           created_date = date('2024-01-10'),
           due_datetime = '2024-01-12 10:30:00',
           estimated_hours = 0.5,
           priority_score = 30,
           cost = 0.00,
           task_id = uuid()
        """,
    )

    # Insert task with many NULL fields (minimal required data)
    db.command(
        "sql",
        """INSERT INTO Task SET
           title = 'Research ArcadeDB features',
           priority = 'medium',
           completed = false,
           tags = ['work', 'research'],
           created_date = date('2024-01-17'),
           due_datetime = NULL,
           estimated_hours = NULL,
           priority_score = 60,
           cost = NULL,
           task_id = uuid()
        """,
    )

    # Note: Arrays (lists) work naturally - no need for JSON serialization!
    # NULL values represent optional/missing data
    # uuid() generates unique identifiers automatically
    # Documents can contain: strings, numbers, booleans, arrays, nested objects, NULLs

print("   ‚úÖ Inserted 4 tasks (with various data types and NULL values)")
print("   üí° Transaction committed automatically at end of 'with' block")
print("   üí° NULL values used for optional fields (due_datetime, cost, etc.)")
print("   üí° uuid() function generates unique task IDs automatically")
print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
print()

# -----------------------------------------------------------------------------
# Step 4: QUERY - Read Documents
# -----------------------------------------------------------------------------
print("Step 4: Querying documents...")
print()

step_start = time.time()

# Query all tasks with all properties
print("   üìã All tasks (with data types):")
result = db.query("sql", "SELECT FROM Task ORDER BY priority_score DESC")

for record in result:
    # Access properties using get_property() method
    title = str(record.get_property("title"))
    priority = str(record.get_property("priority"))
    completed = record.get_property("completed")
    estimated_hours = record.get_property("estimated_hours")
    cost = record.get_property("cost")
    due = record.get_property("due_datetime")
    task_id = str(record.get_property("task_id"))

    status = "‚úÖ" if completed else "‚è≥"

    # Handle NULL values in display
    hours_str = f"{estimated_hours}h" if estimated_hours is not None else "N/A"
    # DECIMAL type is Java BigDecimal - convert via string to float
    if cost is not None:
        cost_str = f"${float(str(cost)):.2f}"
    else:
        cost_str = "N/A"
    due_str = str(due)[:10] if due is not None else "No deadline"

    print(f"      {status} [{priority:6}] {title}")
    print(f"         Time: {hours_str}, Cost: {cost_str}, Due: {due_str}")
    print(f"         UUID: {task_id}")

print()

# Query with WHERE clause - find incomplete high priority tasks
print("   üî• High priority incomplete tasks:")
result = db.query(
    "sql", "SELECT FROM Task WHERE priority = 'high' AND completed = false"
)

count = 0
for record in result:
    title = str(record.get_property("title"))
    tags = record.get_property("tags")
    print(f"      ‚Ä¢ {title}")
    # Convert Java array to Python list for display
    tag_list = [str(tag) for tag in tags]
    print(f"        Tags: {', '.join(tag_list)}")
    count += 1

if count == 0:
    print("      (none found)")

print()

# Query for tasks with NULL values (no deadline)
print("   ‚è∞ Tasks without deadlines (due_datetime IS NULL):")
result = db.query("sql", "SELECT FROM Task WHERE due_datetime IS NULL")

count = 0
for record in result:
    title = str(record.get_property("title"))
    priority = str(record.get_property("priority"))
    print(f"      ‚Ä¢ [{priority}] {title}")
    count += 1

if count == 0:
    print("      (none found)")
else:
    print(f"      üí° Found {count} task(s) with NULL deadline")

print()

# Query for tasks with NULL cost
print("   üí∞ Tasks without cost estimate (cost IS NULL):")
result = db.query("sql", "SELECT FROM Task WHERE cost IS NULL")

count = 0
for record in result:
    title = str(record.get_property("title"))
    print(f"      ‚Ä¢ {title}")
    count += 1

if count == 0:
    print("      (none found)")
else:
    print(f"      üí° Found {count} task(s) with NULL cost")

print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
print()

# -----------------------------------------------------------------------------
# Step 5: UPDATE - Modify Documents (including setting NULL)
# -----------------------------------------------------------------------------
print("Step 5: Updating documents...")
print()

step_start = time.time()

# Mark 'Buy groceries' as completed and add actual cost
with db.transaction():
    db.command(
        "sql",
        """UPDATE Task SET
           completed = true,
           cost = 127.50
           WHERE title = 'Buy groceries'""",
    )

print("   ‚úÖ Marked 'Buy groceries' as completed and set actual cost")
print()

# Update a task to set NULL value (cancel cost estimate)
with db.transaction():
    db.command(
        "sql",
        """UPDATE Task SET
           cost = NULL,
           estimated_hours = NULL
           WHERE title = 'Call dentist'""",
    )

print("   ‚úÖ Cleared cost and time estimates for 'Call dentist' (set to NULL)")
print()

# Verify the updates
print("   üìä Updated task list (with NULL handling):")
result = db.query("sql", "SELECT FROM Task ORDER BY completed, priority_score DESC")

for record in result:
    title = str(record.get_property("title"))
    priority = str(record.get_property("priority"))
    completed = record.get_property("completed")
    cost = record.get_property("cost")
    estimated_hours = record.get_property("estimated_hours")

    status = "‚úÖ" if completed else "‚è≥"

    # Show how NULL values appear (convert DECIMAL via string to float)
    if cost is not None:
        cost_str = f"${float(str(cost)):.2f}"
    else:
        cost_str = "NULL"
    hours_str = f"{estimated_hours}h" if estimated_hours is not None else "NULL"

    print(f"      {status} [{priority:6}] {title}")
    print(f"         Cost: {cost_str}, Hours: {hours_str}")

print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
print()

# -----------------------------------------------------------------------------
# Step 6: Advanced Queries
# -----------------------------------------------------------------------------
print("Step 6: Running aggregation queries...")
print()

step_start = time.time()

# Count total tasks
result = db.query("sql", "SELECT count(*) as total FROM Task")
total = list(result)[0].get_property("total")
print(f"   üìä Total tasks: {total}")

# Count by priority
result = db.query(
    "sql", "SELECT priority, count(*) as count FROM Task GROUP BY priority"
)
print("   üìä Tasks by priority:")
for record in result:
    priority = str(record.get_property("priority"))
    count = record.get_property("count")
    print(f"      ‚Ä¢ {priority}: {count}")

# Count completed vs incomplete
result = db.query(
    "sql", "SELECT completed, count(*) as count FROM Task GROUP BY completed"
)
print("   üìä Completion status:")
for record in result:
    completed = record.get_property("completed")
    count = record.get_property("count")
    status = "Completed" if completed else "Incomplete"
    print(f"      ‚Ä¢ {status}: {count}")

print(f"   ‚è±Ô∏è  Time: {time.time() - step_start:.3f}s")
print()

# -----------------------------------------------------------------------------
# üí° ArcadeDB SQL Key Difference: No JOINs
# -----------------------------------------------------------------------------
print("üí° ArcadeDB SQL Key Difference: No JOINs")
print()
print("   ArcadeDB uses LINKS instead of JOINs for relationships.")
print("   Instead of traditional JOIN syntax, use dot notation:")
print()
print("   ‚ùå Traditional SQL (not supported):")
print("      SELECT * FROM Employee A, City B")
print("      WHERE A.city = B.id AND B.name = 'Rome'")
print()
print("   ‚úÖ ArcadeDB SQL (dot notation):")
print("      SELECT * FROM Employee WHERE city.name = 'Rome'")
print()
print("   This makes queries simpler and more intuitive!")
print()

# -----------------------------------------------------------------------------
# Step 7: DELETE - Remove Documents
# -----------------------------------------------------------------------------
print("Step 7: Deleting documents...")
print()

# Delete completed tasks
with db.transaction():
    result = db.command("sql", "DELETE FROM Task WHERE completed = true")

print("   üóëÔ∏è  Deleted all completed tasks")
print()

# Verify deletion
result = db.query("sql", "SELECT count(*) as remaining FROM Task")
remaining = list(result)[0].get_property("remaining")
print(f"   üìä Remaining tasks: {remaining}")
print()

# Show remaining tasks
print("   üìã Remaining tasks:")
result = db.query("sql", "SELECT FROM Task ORDER BY priority DESC")

for record in result:
    title = str(record.get_property("title"))
    priority = str(record.get_property("priority"))
    print(f"      ‚è≥ [{priority:6}] {title}")

print()

# -----------------------------------------------------------------------------
# Step 8: Cleanup
# -----------------------------------------------------------------------------
print("Step 8: Cleanup...")
print()

# Close database connection
db.close()
print("   ‚úÖ Database closed")

# Note: We're NOT deleting the database directory
# You can inspect the files in ./my_test_databases/task_db/
print(f"   üí° Database files preserved at: {db_path}")
print("   üí° Inspect the database structure and files!")
print("   üí° Re-run this script to recreate the database")

print()
print("=" * 70)
print("‚úÖ Example Complete!")
print("=" * 70)
print()
print("üìö What you learned:")
print("   ‚Ä¢ Creating embedded databases (no server needed)")
print("   ‚Ä¢ Using context managers for transactions")
print("   ‚Ä¢ CRUD operations with SQL")
print("   ‚Ä¢ Querying and filtering data")
print("   ‚Ä¢ Working with flexible document schema")
print()
print("üí° Files created:")
print("   ‚Ä¢ ./my_test_databases/task_db/ - Database files:")
print("     - configuration.json - Database configuration")
print("     - schema.json - Schema definition (types & properties)")
print("     - Task_0.1.65536.v0.bucket - Data bucket with Task documents")
print("     - dictionary.0.327680.v0.dict - String compression dictionary")
print("     - statistics.json - Database statistics")
print("   ‚Ä¢ ./log/ - ArcadeDB and JVM log files")
print()
print("üí° Next steps:")
print("   ‚Ä¢ See docs/examples/ for detailed explanations")
print("   ‚Ä¢ See docs/guide/operations.md for file structure and logging")
print()
print("üîó API Documentation:")
print("   ‚Ä¢ Database: docs/api/database.md")
print("   ‚Ä¢ Transactions: docs/api/transactions.md")
print("   ‚Ä¢ Results: docs/api/results.md")
print()
